### 프로세스  
- `프로그램` : 하드디스크에 저장되어있는 파일  
- `프로세스` : 실행중인 프로그램  
자원(메모리, cpu)과 쓰레드로 구성됨  

- `쓰레드` : 프로세스 내에서 실제 작업을 수행하는 것.  
처리율을 향상시킬 수 있음.  
여러 쓰레드들은 모두 개별적인 제어 흐름을 갖는다.  
---

    프로세스 : 쓰레드 = 공장 : 일꾼  
`싱글 쓰레드 프로세스` : 자원 + 쓰레드  
`멀티 쓰레드 프로세스` : 자원 + 쓰레드 + 쓰레드 ...  

#### 멀티쓰레드의 장점  
![Alt text](<../../image/멀티쓰레드의 장단점.JPG>)  
#### 멀티쓰레드 동작 순서
![alt text](../../image/thread.PNG)  
- 동시(Concurrency) : 여러 작업을 cpu 코어 수만큼 나눠서 번갈아가며 수행.  
하나의 CPU를 동시에 사용.  
- 병렬(Parallelism) : 작업들이 각각의 코어에 할당되어 수행.  

> `작업 수` > `코어 수` = <span style = "color:blue">동시</span>    
`작업 수` < `코어 수` = <span style = "color:green">병렬</span>  

코어가 여러 개이고, 작업 수가 더 많다면 동시성과 병렬성을 모두 가짐.  

### 쓰레드 생성 및 실행  
방법 1. Thread 클래스를 상속하여 `클래스`를 만들고  
`run() 메서드`를 `Override`  

방법 2. Runnable 인터페이스를 구현하여 `run()메서드`를 `Override` 한 후,  
Thread의 생성자 매개변수로 구현한 놈을 넘겨줌.  

Thread을 구현하느냐, Runnable을 구현하느냐 차이.  
둘이 뭐가 다르냐?  

- `run()` 메서드에는 작업을 작성.  
`start()` 메서드로 Thread 실행!!!!  
객체 별로 `실행`은 `한 번만` 가능. 더 실행하면 예외 발생. `(IllegalThreadStateException)`  

- 동영상과 자막 파일 동시 송출을 예시로 만들어 보았음.  
Thread.sleep() 메서드로 싱크 조절.  



```java
package CreateAndStartThread_M1C1;

// 방법 1. Thread 클래스를 상속해 쓰레드 클래스 2개 생성

class SMIFileThread extends Thread{
	@Override	// run()을 Override하지만 실행은 start()로
	public void run() {
		// 자막 번호 하나~ 다섯
		String[] strArray = {"하나", "둘", "셋", "넷", "다섯"};
		try {Thread.sleep(10);}catch(InterruptedException e) {}	// 싱크 맞추기. Thread 준비 시간을 줌.
		// 자막 번호 출력
		for(String str : strArray) {
			System.out.println(" - (자막번호) " + str);
			try {Thread.sleep(200);}catch(InterruptedException e) {}
		}
	}
}

class VideoFileThread extends Thread{
	@Override	// run()을 Override하지만 실행은 start()로
	public void run() {
		// 비디오 프레임 번호 1~5
		int[] intArray = {1, 2, 3, 4, 5};
		// 비디오 프레임 출력
		for(int i : intArray) {
			System.out.print("(비디오 프레임) " + i);
			try {Thread.sleep(200);}catch(InterruptedException e) {}
		}
	}
}
public class CreateAndStartThread_M1C1 {

	public static void main(String[] args) {
		
		// SMIFileThread 객체 생성 및 시작
		Thread sFT = new VideoFileThread();
		Thread vFT = new SMIFileThread();
		sFT.start();// 새로운 쓰레드가 생성됨. Thread-0
		vFT.start();	
        // 배열로 관리 가능.
        Thread[] threads = {new VideoFileThread(), new SMIFileThread()};
		for (Thread thread : threads) thread.start();
	}
}
```
```java
// 방법 2. Runnable을 구현해 쓰레드 3개 생성  
package CreateAndStartThread_M2C1;

class VideoFileRunnable implements Runnable{
	@Override
	public void run() {
		int[] intArray = {1, 2, 3, 4, 5};
		for (int i : intArray) {
			System.out.print("(비디오 프레임) "+ i);
			try {Thread.sleep(100);} catch(InterruptedException e) {}
		}
	}
}

class SMIFileRunnable implements Runnable {
	@Override
	public void run() {
		// 자막 번호 하나~다섯
		String[] strArray = {"하나", "둘", "셋", "넷", "다섯"};
		try {Thread.sleep(10);} catch(InterruptedException e) {}
		// 자막 번호 출력
		for (int i = 0; i<strArray.length; i++) {
			System.out.print(" - (자막 번호) " + strArray[i]);
			try {Thread.sleep(110);} catch(InterruptedException e) {}
		}
	}
}

class EnglishFileRunnable implements Runnable{
	@Override
	public void run() {
		String[] strArray = {"One", "Two", "Three", "Four", "Five"};
		try {Thread.sleep(20);}catch(InterruptedException e) {}
		for(String a : strArray) {
			System.out.println(" - Eng : " + a);
			try {Thread.sleep(120);} catch(InterruptedException e) {}
		}
	}
}

public class CreateAndStartThread_M2C1 {

	public static void main(String[] args) {
        // 익명 내부 클래스로 구현해도 됨.
		VideoFileRunnable vfr = new VideoFileRunnable();
		SMIFileRunnable sfr = new SMIFileRunnable();
        EnglishFileRunnable efr = new EnglishFileRunnable();

		Thread[] threads = {new Thread(vfr), new Thread(sfr), new Thread(efr)};
		for (Thread t : threads) t.start();
	}
}
```
Runnable과 Thread 둘 다 배열로 관리도 가능  
```java
        // 둘 다 배열로 관리
		Runnable[] frs = {new VideoFileRunnable(), new SMIFileRunnable(), new EnglishFileRunnable()};
		Thread[] threads = new Thread[frs.length];
		for (int i = 0; i<frs.length;i++) {
			threads[i] = new Thread(frs[i]);
		}
		for(Thread t : threads) t.start();
```

### Thread의 속성  

- `.currentThread()` : 현재 실행중인 쓰레드 참조값 반환   
- `.activeCount()` : 현재 실행중인 쓰레드 개수 반환  
- `setName() / getName()` : 쓰레드 이름 설정 / 반환  

예시  
```java
package ThreadProperties_1;

// 쓰레드 객체의 속성 다루기

public class ThreadProperties_1 {
	public static void main(String[] args) {
		
		//객체 참조하기, 쓰레드의 개수 가져오기
		Thread curThread = Thread.currentThread();
		System.out.println("현재 쓰레드의 이름 = " +  curThread.getName());
		System.out.println("동작하는 쓰레드의 개수 = " + Thread.activeCount());
		
		// 쓰레드 이름 자동 지정
		for(int i = 0; i<3; i++) {
			Thread thread = new Thread();
			System.out.println(thread.getName());
			thread.start();
		}
		// 쓰레드 이름 직접 설정
		for(int i = 0; i<3; i++) {
			Thread thread = new Thread();
			thread.setName(i + "번째 쓰레드");
			System.out.println(thread.getName());
			thread.start();
		}
		// 쓰레드 이름 자동 지정
		for(int i = 0; i<3; i++) {
			Thread thread = new Thread();
			System.out.println(thread.getName());
			thread.start();
		}
		// 쓰레드의 개수 가져오기
		System.out.println("동작하는 쓰레드의 개수 = " + Thread.activeCount());// 실행 완료된 쓰레드는 제외
	}

}
```
실행 결과 :  
```java
현재 쓰레드의 이름 = main
동작하는 쓰레드의 개수 = 1
Thread-0
Thread-1
Thread-2
0번째 쓰레드
1번째 쓰레드
2번째 쓰레드
Thread-6
Thread-7
Thread-8
동작하는 쓰레드의 개수 = 4
```