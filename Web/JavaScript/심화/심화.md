## 템플릿 리터럴  
기존에는 문자열, 변수를 출력하려면 ",'를 활용해 번거롭게 작성해야 했음.  
```javascript
const name = "이름"; 
const classroom = 201;
document.write("<h1>"+name+"님, "+classroom+"호 강의실로 입장하세요<h1>");
```
템플릿 리터럴을 이용하면 좀 더 쉽게 작성할 수 있음.  
```javascript
document.write(`<h1>${name}님 , ${classroom}호 강의실로 입장하세요<h1/>`);
```
템플릿 리터럴을 작성할 때는 문자열 전체를 백틱 backtick (`)으로 감싸주고, 변수는 ${}로 감싸줌.  

또한 기존 형식으로 작성할 때, 줄바꿈을 하면 문자열 형식이 적용이 안 됐는데  
템플릿 리터럴로 작성할 때는 줄바꿈을 해도 문자열 형식이 적용 됨.  

```javascript
// 기존 형식
console.log("asdfg
            asdfg");

// 템플릿 리터럴
console.log(`asdfg
            asdfg`);
```

## truthy와 falsy  
true와 false라는 명확한 값 외에 참과 거짓을 판별하는 방법.  
truthy는 true로 인정할 수 있는 값,  
falsy는 false로 인정할 수 있는 값.  
falsy값을 제외한 모든 값은 truthy임.  

falsy값 :  
- 0  
- ""  
- NaN   
- undefined : 변수를 선언하기만 하고 값을 할당하지 않았을 때의 초기값. 값이면서 자료형.  
- null : 유효하지 않는 값. null 역시 값이면서 자료형.  

javascript에서 보통 undefined값은 사용자가 실수로 값을 할당하지 않을 경우에 생기고,  
null값은 직접 넣음.  

## 객체  
javascript에서 객체는 key,value로 구성된 property로 이루어져있음.  
```javascript
const book =
    {
        title : '깃허브 입문',
        pubDate : '2099-12-06',
        pages : 272,
        finished : true
    }
book.title // => '깃허브 입문'
book['title']; // => '깃허브 입문'
```
javascript의 객체에 이미 있는 키에 값을 부여하면 값이 변경되고,  
없는 키와 값을 대입하면 자동으로 추가됨.  

## 심볼  
ES6에 새롭게 추가된 원시 유형의 자료형  
심볼은 유일성을 보장하고, 객체 프로퍼티의 키로 사용할 수 있음.  

javascript 오픈 소스를 사용하거나, 다른 팀원이 만든 객체들을 함께 사용할 경우, 객체의 키 이름이 중복될 수 있는데  
심볼을 사용하면 충돌을 피할 수 있음.  

심볼을 만들 때는 Symbol() 함수 사용.  
```javascript
    const | let | var v_name = Symbol();

    // 객체 프로퍼티로 심볼 지정
    let id = Symbol();
    const member = 
    {
        name : "Kim",
        [id] : 12345
    }

    // 객체 심볼 프로퍼티 호출
    member[id]
    
    // 심볼 프로퍼티 추가
    let grade = Symbol("grade");
    member[grade] = "VIP";
    member[grade]   // => "VIP"
```

## 자료형  
javascript에서는 자동으로 형변환됨.  
```javascript
num = 20;
num = "John";
num // => "John"
```
그런데 자동 형변환이 일관성 없이 일어남.  
```javascript
// 문자 + 숫자 = 문자  
"20" + 10 = "2010"  

//문자 - 숫자 = 숫자  
"20" - 10 = 10  

Number(true)
=> 1
Number(false)
=> 0
Number(null)
=> 0
Number(undefined)
=> NaN
```
또한 prompt로 입력받은 값들은 string으로 들어옴.  
때문에 자료형을 명시하는 것이 좋음.  

- parseInt() : 정수형으로 변환하는 함수 
- parseFloat() : 실수형으로 변환하는 함수  
(꼼수 : prompt 앞에 '+'를 앞에 붙이면 숫자로 변환됨. 근데 가끔 작동이 안 될 때가 있음.)  
- toString() : null과 undefined 형을 제외한 데이터형을 문자열로 변환. 매개변수로 2, 8, 16 등을 넣으면 2진수, 8진수, 16진수로 변환.  
    (String()로도 가능.)  
- Boolean() : 논리형으로 변환하는 함수  
    0, 빈 문자열, undefined는 false.  
    나머지는 true.  

## forEach문  
> 배열에 사용하는 반복문  
배열의 크기(length)가 정해져 있지 않을 경우에 사용함.  
for문보다 더 자주 사용함.  

```
배열명.forEach(콜백 함수){...}
```

배열 요소 값 표시 예시  

```javascript
const students = ["Park","Kim","Lee","Kang"];
students.forEach(function(student)){
    document.write(`${student}. `)
});
// students 배열에 있는 각 요소를 student라 하고, student 표시
// 화살표 함수로 간단히 표현
students.forEach(student => document.write(`${student}. `));
```
객체 출력은 forEach를 사용할 수 없음.  

## forOf문  
> forEach처럼 배열에 사용하는 반복문.  
```javascript
const students = ["Park","Kim","Lee","Kang"];
for(s of students)
    {
        document.write(`<br>${s}`);
    }
```

## forIn문  
> 객체 전용 반복문.  
객체의 key와 value를 출력할 때 사용함.  
```javascript
for (변수 in 객체) {
    ...
    // 변수는 key를,
    // 객체[변수]는 value를 가져옴. 
}
```
``` javascript
const book = {
    title : "git",
    pubDate : "2099-01-01",
    pages : 272,
    finished : true
}

for ( key in book ) // key는 변수
    {
        document.write(`${key} : ${book[key]}<br>`);
        // key와 value를 출력
    }

const jelly = 
{
    name : "Jellycious",
    flavor : "Lemon",
    fromWho : "좌측 신사분",
    isGood : true
};

for(k in jelly)
    {
        document.write(`${k} : ${jelly[k]}<br>`);
    };
    
```

객체에 사용할 수 없는 이유 : 반복 가능한 데이터 내에는 .next()라는 메서드가 있는데,  
반복하면서 이를 호출하기 때문에 .next()가 없는 `객체`는 반복될 수 없음.  

반대로 forIn를 반복 가능한 데이터에 사용한다면, 값이 나오는게 아니라 인덱스 번호가 반환됨.  
배열[변수] 형태로 출력하면 값이 출력되긴 하지만, 이럴 바엔 forEach나 forOf를 사용할듯.  

## 콜백 함수  
> 직접적으로 호출하지 않고, 간접적으로 호출하는 함수를 콜백 함수라고 함.  

```javascript
const btn = document.querySelector("button");
btn.addEventListener("click", ()=>{
    alert("클릭했습니다");
});
```
여기서 화살표 함수도 콜백 함수.  

보통 사용하는 방식은, 함수를 통해 다른 함수를 부르는 건데  
A 함수에 B 함수를 매개변수로 받아 호출한다면, A 함수 내에 함수를 콜백 함수라고 함.  

```javascript
    document.querySelector("button").addEventListener("click",runner);

    function runner() { getData(writeData) }
    function showData(name,age){
        alert(`안녕하세요? ${name}님, 나이가 ${age}이십니다.`);
    }
    function writeData(name, age){
        document.write(`<p>${name}님, 나이가 ${age}이십니다.</p>`);
    }
    function getData(callBack){ // 매개변수로 함수를 전달받아서 간접적으로 실행
        const userName = prompt("이름을 입력하세요");
        const userAge = prompt("나이를 입력하세요");
        callBack(userName,userAge); // 콜백함수
    }
```

자바스크립트의 함수는 다음과 같은 조건들을 만족함  
- 변수에 할당될 수 있어야 함.  
- 다른 함수의 인자로 활용할 수 있어야 함.  
- 다른 함수에서 반환값으로 반환될 수 있어야 함.  
이런 특징으로 자바스크립트의 함수를 1급 시민(first-class citizen) 이라고 부름.  

대부분 이런 형식으로 코드를 짜기 때문에, 구조를 이해하는 것이 중요함.  
