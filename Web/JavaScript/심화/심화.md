## 템플릿 리터럴  
기존에는 문자열, 변수를 출력하려면 ",'를 활용해 번거롭게 작성해야 했음.  
```javascript
const name = "이름"; 
const classroom = 201;
document.write("<h1>"+name+"님, "+classroom+"호 강의실로 입장하세요<h1>");
```
템플릿 리터럴을 이용하면 좀 더 쉽게 작성할 수 있음.  
```javascript
document.write(`<h1>${name}님 , ${classroom}호 강의실로 입장하세요<h1/>`);
```
템플릿 리터럴을 작성할 때는 문자열 전체를 백틱 backtick (`)으로 감싸주고, 변수는 ${}로 감싸줌.  

또한 기존 형식으로 작성할 때, 줄바꿈을 하면 문자열 형식이 적용이 안 됐는데  
템플릿 리터럴로 작성할 때는 줄바꿈을 해도 문자열 형식이 적용 됨.  

```javascript
// 기존 형식
console.log("asdfg
            asdfg");

// 템플릿 리터럴
console.log(`asdfg
            asdfg`);
```

배열을 넣으면 요소들이 한 줄로 출력됨.  

```javascript
items=['pen','pencil','ink','shovel'];
console.log(`items : ${items} `);
// => items : pen,pencil,ink,shovel
```

---

## truthy와 falsy  
true와 false라는 명확한 값 외에 참과 거짓을 판별하는 방법.  
truthy는 true로 인정할 수 있는 값,  
falsy는 false로 인정할 수 있는 값.  
falsy값을 제외한 모든 값은 truthy임.  

falsy값 :  
- 0  
- ""  
- NaN   
- undefined : 변수를 선언하기만 하고 값을 할당하지 않았을 때의 초기값. 값이면서 자료형.  
- null : 유효하지 않는 값. null 역시 값이면서 자료형.  

javascript에서 보통 undefined값은 사용자가 실수로 값을 할당하지 않을 경우에 생기고,  
null값은 직접 넣음.  


---

## 심볼  
ES6에 새롭게 추가된 원시 유형의 자료형  
심볼은 한 번 정의하면 값을 변경할 수 없고, 유일한 값을 가짐. 또한 객체 프로퍼티의 키로 사용할 수 있음.  
또한 심벌을 사용해 프로퍼티를 정의하면, 심볼 키에 접근할 수 없고 정보가 드러나지 않음.  

javascript 오픈 소스를 사용하거나, 다른 팀원이 만든 객체들을 함께 사용할 경우, 객체의 키 이름이 중복될 수 있는데  
심볼을 사용하여 프로퍼티를 지정하면 충돌을 피할 수 있음.  

심볼을 만들 때는 Symbol() 함수 사용.  
```javascript
    const | let | var v_name = Symbol();

    // 객체 프로퍼티로 심볼 지정
    let id = Symbol();
    const member = 
    {
        name : "Kim",
        [id] : 12345
    }

    // 객체 심볼 프로퍼티 호출
    member[id]
    
    // 심볼 프로퍼티 추가
    let grade = Symbol("grade");
    member[grade] = "VIP";
    member[grade]   // => "VIP"
```

``` javascript
    // forIn문을 사용하면, 심볼 프로퍼티는 반환되지 않음.
    const id = Symbol("id");
    const tel = Symbol("telephone number");
    const member = {
        name : "Kim",
        age : 25,
        [id] : 1235,
        [tel] : function () {
            alert(prompt("전화번호 : "));
        }
    }

    for(item in member) {
        console.log(`${item} : ${member[item]}`);
    }
    // name : Kim
    // age : 25
```

![alt text](image.png)  

### 전역 심벌  
여러 군데에서 사용할 수 있는 심벌.  
전역 심벌에 접근하려면 아래 메서드를 사용해야 함.  

#### Symbol.for() 메서드  
키를 인수로 받고 전역 심벌 레지스트리를 뒤져서 키에 해당하는 심벌을 찾음.  
레지스트리에 키에 맞는 심벌이 있으면 해당 심벌을 반환하고, 그렇지 않으면 새로운 심벌을 만들어서 반환함.  

```javascript
Symbol.for(키)
// 키에 해당하는 심볼을 반환.

let tel = Symbol.for("tel") // 심벌 생성
let phone = Symbol.for("tel") // tel에 대한 심벌이 이미 있으므로 
tel === phone // true
```

#### Symbol.keyFor() 메서드  
심벌값을 인수로 받아서 전역 심벌 레지스트리를 뒤져서 심벌값의 키를 찾음.  
```javascript
Symbol.keyFor(심벌값)

let tel = Symbol.for("tel");
let phone = Symbol.for("tel");
tel === phone // true
Symbol.keyFor(phone)    // "tel"
```



---

## 자료형  
javascript에서는 자동으로 형변환됨.  
```javascript
num = 20;
num = "John";
num // => "John"
```
그런데 자동 형변환이 일관성 없이 일어남.  
```javascript
// 문자 + 숫자 = 문자  
"20" + 10 = "2010"  

//문자 - 숫자 = 숫자  
"20" - 10 = 10  

Number(true)
=> 1
Number(false)
=> 0
Number(null)
=> 0
Number(undefined)
=> NaN
```
또한 prompt로 입력받은 값들은 string으로 들어옴.  
때문에 자료형을 명시하는 것이 좋음.  

- parseInt() : 정수형으로 변환하는 함수 
- parseFloat() : 실수형으로 변환하는 함수  
(꼼수 : prompt 앞에 '+'를 앞에 붙이면 숫자로 변환됨. 근데 가끔 작동이 안 될 때가 있음.)  
- toString() : null과 undefined 형을 제외한 데이터형을 문자열로 변환. 매개변수로 2, 8, 16 등을 넣으면 2진수, 8진수, 16진수로 변환.  
    (String()로도 가능.)  
- Boolean() : 논리형으로 변환하는 함수  
    0, 빈 문자열, undefined는 false.  
    나머지는 true.  

---

## 반복문  
`forEach` : 배열에 사용되는 함수. 반복문과 같은 효과를 냄.  
`forIn` : 객체에만 사용되는 반복문 (key 안에(in) value)  
`forOf` : 반복가능한 객체에 사용하는 반복문  


### forEach()문  
> 배열에 사용하는 함수  
배열의 크기(length)가 정해져 있지 않을 경우에 사용함.  
for문보다 더 자주 사용함.  

```
배열명.forEach(콜백 함수){...}
```

배열 요소 값 표시 예시  

```javascript
const students = ["Park","Kim","Lee","Kang"];
students.forEach(function(student)){
    document.write(`${student}. `)
});
// students 배열에 있는 각 요소를 student라 하고, student 표시
// 화살표 함수로 간단히 표현
students.forEach(student => document.write(`${student}. `));
```
객체 출력은 forEach를 사용할 수 없음.  


### forIn문  
> 객체 전용 반복문.  
객체의 key와 value에 접근할 때 사용함.  
```javascript
for (변수 in 객체) {
    ...
    // 변수는 key를,
    // 객체[변수]는 value를 가져옴. 
}
```
``` javascript
const book = {
    title : "git",
    pubDate : "2099-01-01",
    pages : 272,
    finished : true
}

for ( key in book ) // key는 변수
    {
        document.write(`${key} : ${book[key]}<br>`);
        // key와 value를 출력
    }

const jelly = 
{
    name : "Jellycious",
    flavor : "Lemon",
    fromWho : "좌측 신사분",
    isGood : true
};

for(k in jelly)
    {
        document.write(`${k} : ${jelly[k]}<br>`);
    };
    
```

### forOf문  
> 배열 말고도, iterable한 객체에도 사용 가능한 반복문.  

```javascript
const students = ["Park","Kim","Lee","Kang"];
for(s of students)
    {
        document.write(`<br>${s}`);
    }
```

객체에 사용할 수 없는 이유 : 반복 가능한 데이터 내에는 .next()라는 메서드가 있는데,  
반복하면서 이를 호출하기 때문에 .next()가 없는 `객체`는 반복될 수 없음.  

반대로 forIn를 반복 가능한 데이터에 사용한다면, 값이 나오는게 아니라 인덱스 번호가 반환됨.  
배열[변수] 형태로 출력하면 값이 출력되긴 하지만, 이럴 바엔 forEach나 forOf를 사용할듯.  



## 콜백 함수  
> 직접적으로 호출하지 않고, 간접적으로 호출하는 함수를 콜백 함수라고 함.  

```javascript
const btn = document.querySelector("button");
btn.addEventListener("click", ()=>{
    alert("클릭했습니다");
});
```
여기서 화살표 함수도 콜백 함수.  

보통 사용하는 방식은, 함수를 통해 다른 함수를 부르는 건데  
A 함수에 B 함수를 매개변수로 받아 호출한다면, A 함수 내에 함수를 콜백 함수라고 함.  

```javascript
    document.querySelector("button").addEventListener("click",runner);

    function runner() { getData(writeData) }
    function showData(name,age){
        alert(`안녕하세요? ${name}님, 나이가 ${age}이십니다.`);
    }
    function writeData(name, age){
        document.write(`<p>${name}님, 나이가 ${age}이십니다.</p>`);
    }
    function getData(callBack){ // 매개변수로 함수를 전달받아서 간접적으로 실행
        const userName = prompt("이름을 입력하세요");
        const userAge = prompt("나이를 입력하세요");
        callBack(userName,userAge); // 콜백함수
    }
```

자바스크립트의 함수는 다음과 같은 조건들을 만족함  
- 변수에 할당될 수 있어야 함.  
- 다른 함수의 인자로 활용할 수 있어야 함.  
- 다른 함수에서 반환값으로 반환될 수 있어야 함.  
이런 특징으로 자바스크립트의 함수를 1급 시민(first-class citizen) 이라고 부름.  

대부분 이런 형식으로 코드를 짜기 때문에, 구조를 이해하는 것이 중요함.  

## spread 연산자 (전개 구문)  

배열 앞에 `...`을 써서 요소들을 한 줄에 모두 반환.  

```javascript
fruits=['apple','banana','grape'];
console.log(...fruits)
// => apple banana grape
```

삽입할 때 유용하게 쓰임.  
concat 메서드보다 편함.  

```javascript
items1 = [1,2,3]
items2 = [4,5,6]

newItems = items1+items2;
// newItems => '1,2,34,5,6' 

newItems = [items1,items2];
// newItems => [Array(3),Array(3)]

newItems = items1.concat(items2);
// newItems => [1,2,3,4,5,6]

newItems = [...items1, ...items2];
// newItems => [1,2,3,4,5,6]
```

매개변수 개수가 정해져 있는 함수를 사용할 때, 더 많은 매개변수를 전달 받으면 자바스크립트는 에러가 나지 않고  
정해진 개수만큼만 연산해서 반환함.  

이 때, 매개변수로 spread 연산자를 넣으면 매개변수 개수가 따로 정해지지 않음.  

```javascript
function addNumber(int a, int b){
    let sum = 0;
    sum = a + b;
    return sum;
};

addNumber(1,3,5,7);     
// => 4    매개변수 2개만 적용 됨

function addNum(...numbers) {
    let sum = 0;
    for(let number of numbers) {sum += number};
    return sum;
}

addNum(1,3,5,7);
// => 16
```
길이가 정해져 있지 않은 배열 중 특정 부분을 사용해야 할 때는, first 같은 키워드를 사용할 수 있음.  

```javascript 
function displayFavorites(first, ...favs){
    let str = '';
    favs.forEach(f=>str+=`${f}, `);
    str += `중에서 제가 제일 좋아하는 과일은 ${first}입니다.`
    console.log(str);
}

displayFavorites('복숭아','사과','포도','수박');
// => 사과, 포도, 수박, 중에서 제가 제일 좋아하는 과일은 복숭아입니다.

function getAverage(first, ...scores) {
    let avg = 0;
    scores.forEach(score=>{avg += score});
    avg /= scores.length;
    console.log(`${first}의 평균 점수는 ${avg}입니다.`);
}
getAverage('철수',100,80,100);
// => 철수의 평균 점수는 93.33333333333333입니다.

function showScores(first, ...scores){
    console.log(`${first}의 점수들은 각각 ${scores} 입니다.`);
}
showScores('영희', 100, 80, 90, 100);
// => 영희의 점수들은 각각 100,80,90,100 입니다.

```

---

## 타이머 함수  
특정 시간이 되었을 때, 또는 특정 시간 동안 반복해서 실행하는 함수  

### setInterval()  
일정 시간마다 반복하는 함수.  
시간은 밀리초 단위.  

반복 중지 구문을 정하지 않으면, 페이지 이동, 브라우저 종료, 새로고침하기 전까지 무한 반복  

```javascript
setInterval(콜백함수, 시간)

function greeting() {console.log("안녕하세요");}
setInterval(greeting, 2000);
```

### clearInterval()  
타이머 함수를 멈추는 함수  

```javascript
clearInterval(함수);

const timer = setInterval(()=>console.log("ㅎㅇ"),2000);
clearInterval(timer);

// 5번 출력 후 멈춤
let time = 0;
const interHi = setInterval(()=>{
    console.log("안녕하세요");
    time++;
    if (time===5) clearInterval(interHi);
},1000);
```

### setTimeout()  
정해진 시간 뒤에 딱 한 번 실행하는 함수.  
```javascript
setTimeout(함수, 시간)

setTimeout(()=>console.log("안녕하세요"),3000);
// 3초 뒤에 한 번 실행
```

## 이벤트 전파  
이벤트가 발생했을 때, 해당 요소에서만 이벤트가 처리되는 것이 아니라, 해당 요소를 감싸고 있는  
부모 요소, 그리고 그 요소의 부모 요소에서도 똑같이 이벤트가 처리되는데 이걸 `이벤트 전파`라고 함.  

이벤트 리스너를 사용할 때 전파 방식을 지정할 수 있음.  


```
요소.addEventListener(이벤트,함수,캡처 여부);
```

캡처 여부: 이벤트를 캡처할지 여부를 지정. (기본값 = false)  
  true = 캡처링, false = 버블링

`이벤트 버블링` : DOM의 자식 노드에서 부모 노드로 전달. (아래에서 위로)  
`이벤트 캡처링` : DOM의 부모 노드에서 자식 노드로 전달. (위에서 아래로)  

### 이벤트 버블링  
![alt text](../../../image/bubble.PNG)  
이벤트가 발생한 요소에서부터 부모 요소로, 다시 그 요소의 부모 요소로 이벤트가 전달됨.  
모든 브라우저에서 대부분의 이벤트는 버블링 됨.  
[버블링 예제](연습/html/bubbling.html)  

즉 하위 요소 이벤트 발생 시, (동일한 이벤트 리스너가 있는) 상위 요소 이벤트들도 모두 발동되기 때문에 유의해야 함.  

이 때, event.target은 실제 이벤트가 일어난 객체이고,  
event.currenttarget은 이벤트를 처리하는 객체를 반환함.  
[버블링 target 예제](연습/html/propagation.html)  

### 이벤트 캡처링  
![alt text](../../../image/capturing.PNG)  
버블링의 반대.  
부모 요소로부터, 이벤트가 발생한 자식 요소로 이벤트가 전달됨.  

## 객체  
jsp에서 객체는 관련된 정보와 동작을 함께 모아 놓은 것  

- 내장 객체  
    - 문서 객체 모델  
    - 브라우조 객체 모델  
- 사용자 정의 객체  

### 프로퍼티  

javascript에서 객체는 key,value로 구성된 property로 이루어져있음.  
```javascript
const book =
    {
        title : '깃허브 입문',
        pubDate : '2099-12-06',
        pages : 272,
        finished : true
    }
book.title // => '깃허브 입문'
book['title']; // => '깃허브 입문'
```
javascript의 객체에 이미 있는 키에 값을 부여하면 값이 변경되고,  
없는 키와 값을 대입하면 자동으로 추가됨.  

jsp에서 <span style="text-decoration:underline">객체 메서드는 value로 존재할 수 있음.</span>  
그러나 key에는 문자열, 숫자, 심볼만 들어갈 수 있음.  

```javascript  
let book = {
    title : "이름",
    pages : 360,
    buy : function() {
        console.log("이 책을 구입했습니다.");
    }
}

// ES6 
let book = {
    title : "이름",
    pages : 360,
    buy () {
        console.log("이 책을 구입했습니다.");
    }
}
```

객체의 키 값에 접근할 때, 일반적으로 `.` 표기법을 사용하지만, 대괄호`[]`를 사용할 수도 있음.  

```javascript
const book = {
    title : "JS",
    pages : 330,
    done : false
}
book.title  // => "JS"
book[title] // => "JS"
```

메서드에서 객체 속성값을 사용하고 싶을 때, this 키워드를 사용할 수 있음.  

```javascript
const book = {
    title : "JS",
    pages : 330,
    done : false,
    finish() {
        this.done === false ? console.log("읽는 중") : console.log("다 읽음");
    }
}
```

객체의 프로퍼티로 산술식, 함수를 사용할 수도 있음.  

---

### 객체 복사  
자바에서 변수, 참조 변수 복사 같이 `원시 유형 자료 복사`와 `객체 복사`가 있음.  

- 원시 유형 자료 복사는 `값`을 복사함.  
복사한 자료의 값을 변경해도 원래 자료의 값은 그대로임.  

- 객체 복사는 `주소`를 복사함.  
복사한 자료의 값을 변경하면 원래 자료의 값도 변경됨.  

---

### 생성자 함수  
자바에서 클래스 생성자와 같음.  

일반적인 함수와 같은 형식  
함수 이름의 첫 글자는 대문자로 작성.  
함수 내부에서 this를 사용함.  

```javascript
function 함수명(매개변수) {
    this.키1 : 값1,
    this.키2 : 값2,
    ...
    this.메서드1 : function() {...},
    this.메서드2 : function() {...},
    ...
}
// 또는
const 함수명(매개변수) = function () {
    ...
}
```

```javascript
// 생성자 함수
function Book(title, pages, done=false){
    this.title = title;
    this.pages = pages;
    this.done = done;
    this.finish = function() {
        let str = "";
        this.done = false ? str = "읽는중" : str = "다읽음";
        return str;
    }
}
// new 키워드로 객체 생성
const book1 = new Book("웹 표준의 정석", 340);
const book2 = new Book("점프 투 파이썬", 500, true);

// book1의 finish 메서드 사용
console.log(`${book1.title} - ${book1.pages}쪽 - ${book1.finish()}`);
```

객체의 프로퍼티값을 단축해서 표현할 수도 있음.  
아래는 객체를 만들어내는 생성자 함수 예시.  

```javascript
function makeUser(name, age){
    return{
        name : name,
        age : age
    }
}
//  ▼
function makeUser(name, age){
    return{
        name,
        age
    }
}
```

---

### 클래스를 통한 객체 생성  
jsp에서 클래스는, 정확한 클래스 개념이 아니라 생성자 함수를 좀 더 표현하기 쉽게 바꾼,  
syntactic sugar이다.  

위의 생성자 함수를 보기 쉽게 바꾼 것 뿐, 기능은 똑같다.  

```javascript
class Book{
    constructor(title, pages, done){
        this.title = title;
        this.pages = pages;
        this.done = done;
    }
    finish(){
        let str = "";
        this.done === false ? str = "읽는중" : str = "다읽음";
        return str;
    }
}

// 클래스 생성자로 객체 생성
const book1 = new Book("자바자바", 600);
```

---

### 프로토타입  
자바스크립트 객체에서 프로토타입은, 객체를 만들어 내는 원형.  
모든 객체는 프로토타입을 가지고 있고, 프로토타입으로부터 프로퍼티와 메서드를 상속받는다.  
(객체의 원형) 부모와는 다른 개념임.  

![alt text](../../../image/prototypeArr.PNG)  
![alt text](../../../image/prototypeNumString.PNG)  
[[Prototype]] 속성 : 객체가 어디서부터 온 것인지 알려주는 속성  
arr은 프로토타입 Array로부터 온 객체.  

사용자 정의 객체의 prototype은 Object.  

![alt text](../../../image/prototypeObj.PNG)  

`객체.__proto__`, `클래스.prototype`를 통해 프로토타입을 확인할 수 있음.  

프로토타입을 활용하면  
생성자 함수와 함수를 나눠서, 함수를 나중에 추가할 수 있음.

```javascript
// 생성자만 생성
function newBook(title,pages,done){
    this.title = title;
    this.pages = pages;
    this.done = done;
}

// 함수 나중에 추가
newBook.prototype.finish = function() {
    this.done === false ? str = "읽는중" : str = "다읽음";
    return str;
}
```

---

#### 상속

프로토타입을 통해 상속과 같은 효과를 낼 수 있음.  
단, setPrototypeOf(자식.prototype, 부모.prototype)으로 연결해줘야 함.  


```javascript
// Book 생성자
function Book(title,price){
    this.title = title;
    this.price = price;
}
// Book 메서드 추가
Book.prototype.buy = function() {
    console.log(`${this.title}을 ${this.price}원에 구매했습니다.`);
}

// Textbook 생성자
function Textbook(title, price, major) {
    Book.call(this, title, price);  // super(title, price); 부모의 생성자를 호출하는 효과
    this.major = major;
}
// Textbook 메서드
Textbook.prototype.buyTextbook = function() {
    console.log(`${this.major} 전공 서적인, ${this.title}을 ${this.price}에 구매하였습니다.`);
}

// Textbook의 프로토타입과 Book의 프로토타입을 연결하여 상속.
// 자바에서 extends 키워드를 쓰는 것과 같은 효과
Object.setPrototypeOf(Textbook.prototype, Book.prototype);

// Textbook 객체 생성. Book의 메서드도 사용 가능.
const book2 = new Textbook("알고리즘", 5000, "컴퓨터공학");
book2.buyTextbook();
book2.buy();
```
[예제html](연습/html/inheri-1.html),[예제js](연습/js/inheri-1.js)  

---

#### 클래스를 사용한 프로토타입 상속  
위의 방법은 문법적으로 복잡해서, 더 편안하고 보기 쉽게 문법 개선(syntactic sugar)을 한 방법.  
같은 개념인데 문법만 다른 것.  

setProtytypeof 대신에,  
`extends` 키워드와 `super` 생성자를 사용하여 복잡한 문법을 <span style="text-decoration:underline">java 문법과 유사하게 단순화 시킨 방법</span>임.  

```javascript
class Book {
    constructor(title, price){
        this.title = title;
        this.price = price;
    }
    buy(){
        console.log(`${this.title}을 ${this.price}원에 구매하였습니다.`);
    }
}

const book1 = new Book("자료구조",15000);
book1.buy();

class Textbook extends Book{
    constructor(title, price, major){
        super(title, price);
        this.major = major;
    }
    buyTextbook(){
        console.log(`${this.major} 전공서적인 ${this.title}을 ${this.price}원에 구매하였습니다.`);
    }
}
const book2 = new Textbook("인공지능",5000,"컴퓨터공학");
book2.buyTextbook();
book2.buy();
```
![alt text](../../../image/prototypeTextbook.PNG)  
Textbook의 프로토타입은 Book, Book의 프로토타입은 Object  

[예제html](연습/html/inheri-2.html),[예제js](연습/js/inheri-2.js)  

---

## 구조 분해 할당 (destructuring)  
자료의 구조를 분해해서 변수에 할당하는 기능.  
배열이나 객체에서 일부만 꺼내어 다른 변수로 할당할 수 있음.  
활용도가 굉장히 높고, 리액트같은 기술에서도 자주 쓰임.  

```javascript
let[apple,peach] = ["사과","복숭아"]
// 또는
const fruits = ["사과", "복숭아"]
let [apple, peach] = fruits

apple // "사과"
peach // "복숭아"

// 직접 넣을 수도 있음
[apple,peach] = ["사과","복숭아"]
```
<span style="text-decoration:underline">만약 키 개수보다 많은 값을 대입하면, 남는 값들은 버려짐.</span>  

공백으로 구분하여 원하는 부분에만 넣을 수도 있음.  
```javascript
const seasons = ['봄','여름','가을','겨울']
let[spring, , fall, ] = seasons;

spring // '봄'
fall // '가을'
```

... spread 연산자로 각각 지정할 수도 있음.  
```javascript
const ppl = ['kim','lee','park','choi'];
let teacher;
let students;
[teacher, ...students] = ppl;
teacher // 'kim'
students // 'lee', 'park', 'choi'
```

변수의 값을 서로 바꿀 때, 원래라면 temp같은 변수를 따로 지정하여 바꿔줘야 했지만,  
javascript에서는 구조분해할당을 통해 아래와 같은 방법으로 바꿀 수 있음.  
```javascript
let x = 20;
let y = 10;
[x,y] = [y,x]
x // 10
y // 20
```

구조분해할당을 통해 객체의 프로퍼티들을 가져올 수 있음.  
이 때, 배열과 달리 순서대로 가져오는 게 아니라, 키값을 대조하여 동일한 변수값에만 가져옴.  

아래는 변수들에 프로퍼티 값들을 가져오는 예시.  
```javascript
const member= {name:"kim", age:25}
let {name, age} = member;
name // "kim"
age // 25

// 키 값이 다른 변수명은 가져와지지 않음
let {a, b} = member;
a // undefined
b // undefiend
```


같은 변수명을 쓰고 싶지 않은 경우에는  
사실상 이게 원래 구조분해 기본 문법인데, 위의 예시는 객체 프로퍼티명을 단순화한 것임.  
```javascript
const member= {name:"kim", age:25}
let {name : userName, age:a} = member;
userName // "kim"
a // 25
```

구조분해할당을 통해 가져온 객체의 프로퍼티들을 객체에 넣을 수도 있음.  
```javascript
const student = {
    name : "도레미",
    score : {
        history : 85,
        science : 94
    },
        friends : ["Kim","Lee","Park"]
}

let {
    name,
    score: {
        history,
        science
    },
    friends: [f1,f2,f3]
} = student

name    // "도레미"
history // 85
science // 94
f1      // "Kim"
f2      // "Lee"
f3      // "Park"
```

이 또한 변수 명을 다른 이름으로 저장할 수 있음.  

---

## 배열에 같은 함수 적용  
### map()  
각 배열 요소에 똑같은 함수를 실행한 후 그 결과를 새로운 배열로 반환하는 메서드  
매 반복을 순회하여 요소에 적용함.  

매개변수로는 자동으로 배열의 인덱스값들이 들어가게 됨.  
화살표 함수 사용 가능.  

```javascript
// 기본형
map(함수(매개변수))
map(함수(값, 인덱스))   // 인덱스도 함께 출력할 수 있음. 인덱스에는 배열의 인덱스 번호가 각각 들어감
map(함수(값, 인덱스, 배열))

// 예시
let numbers = [1,2,3,4,5]
let newNumbers = numbers.map(number => number*2);
newNumbers      // [2,4,6,8,10]
```  

### filter()  
특정 조건에 맞는 요소만 골라내어 새로운 배열을 반환하는 메서드  

```javascript
filter(함수(값))
filter(함수(값, 인덱스))
filter(함수(값, 인덱스, 배열))

const scores = [90,35,64,77,45,92];
const highScores = scores.filter( s => s>=85 );
highScores  // [90, 92]

// 인덱스 번호도 함께 출력
const scores = [90,35,64,77,45,92]
let highScores = scores.filter((score,index) => {
    if(score>=85){
        console.log(`${index+1}번째 점수 : ${score}`);
        return score;
    }
});
```

### reduce()  
배열 요소에 차례로 함수를 실행하면서 결과값을 하나로 누적하는 메서드  
초기값은 생략할 수 있음. 생략하면 배열의 첫번째 값을 초기값으로 사용함.  
값을 누적하는 누산기라고 이해하면 됨.  

```javascript
reduce(함수(누산기, 현재값, 인덱스, 원래배열), 초기값) // 초기값 생략 가능
// 1.현재값 = 초기값 + 첫번째 배열 요소 실행한 값
// 2. 현재값 = 기존 현재값 + 두번째 배열 요소 실행한 값
// ...


// numbers 배열에 있는 요소들을 차례대로 더하는 예시
const numbers = [1,2,3,4,5];
const result = numbers.reduce( (total, current) =>  {
    return total + current;
}, 0);
result  // 15

// numbers 배열에 있는 요소들을 차례대로 빼는 예시
const numbers = [10,1,2,3];
const result = numbers.reduce((total,current) => {
    return total -= current;
});
result // 4
```
![alt text](../../../image/jsp_reduce.PNG)  
