## class명 지정  
React에서는 className으로 CSS 클래스를 지정합니다.  
```jsx
<img className="avatar" />
```
```css
.avatar {
  border-radius: 50%;
}
```

클릭하면 class 속성이 생기도록 하는 예시  
```jsx
import React from 'react';
import './index.css';
import { useState } from 'react';

// don't change the Component name "App"
export default function App() {
    const [isSelected, setIsSelected] = useState(false);
    return (
        <div>
            <p className={isSelected?'selected':undefined}>Style me!</p>
            <button onClick={()=>{setIsSelected(!isSelected)}}>Toggle style</button>
        </div>
    );
}
```

## forwarding props(프롭들 전달)  

아래 방식처럼 prop을 전달한다면, 새로운 prop이 생길때마다 두 파일 모두 수정해줘야 함.  
```jsx
[Section.jsx]
// 전달받은 title과 children을 사용하여 section 요소를 반환하는 컴포넌트
export default function Section({title, id, children}) {
    return (
        <section id={id}>
            <h2>{title}</h2>
            {children}
        </section>
    )
}
[Examples.jsx]
...
    return(
        <Section id='examples' title='예시들'>
          {/* id와 title prop을 Section 컴포넌트에 전달 */}
          <menu>
          {/* <TapButton children="텍스트"></TapButton> children prop에 값을 넣어줘도 됨 */}
          {/* 하지만 단순 text는 children이라는 props로 전달되도록 설정되어있기 때문에 태그 사이에 적어도 됨 */}
              <TapButton 
              isSelected={seletedTopic === 'components'}
              onSelect={()=>{clickHandler('components')}}>컴포넌트</TapButton>
              <TapButton 
              isSelected={seletedTopic === 'jsx'}
              onSelect={()=>{clickHandler('jsx')}}>JSX</TapButton>
              <TapButton 
              isSelected={seletedTopic === 'props'}
              onSelect={()=>{clickHandler('props')}}>Props</TapButton>
              <TapButton 
              isSelected={seletedTopic === 'state'}
              onSelect={()=>{clickHandler('state')}}>State</TapButton>
          </menu>
        {tabContent}
        </Section>
    );
```

이런 번거로움을 해결할 수 있는 방법이 forwarding props 임.  
전달받을 매개변수를 spread연산자를 사용해 `...변수명`로 받아서  
그대로 전달해주면 자동으로 속성이 추가됨.  
```jsx
[Section.jsx]
export default function Section({title, children, ...props}) {
    return (
        <section {...props}>
            <h2>{title}</h2>
            {children}
        </section>
    )
}
[Example.jsx]
...
  <Section id='examples' title='예시들' className='asdf' wowwow='asdasf'>
...
```
이렇게하면 어떤 속성이 들어와도 동적으로 속성이 추가된다.  


## 데이터 표시하기  
중괄호를 사용하면 코드에서 일부 변수를 삽입하여 사용자에게 표시할 수 있도록 자바스크립트로 “이스케이프 백” 할 수 있습니다.  
JSX 중괄호 안에 문자열 연결과 같이 더 복잡한 표현식을 넣을 수도 있습니다.  

```jsx
const user = {
  name: 'Hedy Lamarr',
  imageUrl: 'https://i.imgur.com/yXOvdOSs.jpg',
  imageSize: 90,
};

export default function Profile() {
  return (
    <>
      <h1>{user.name}</h1>
      <img
        className="avatar"
        src={user.imageUrl}
        alt={'Photo of ' + user.name}
        style={{
          width: user.imageSize,
          height: user.imageSize
        }}
      />
    </>
  );
}
```

## 데이터 반복 표시하기  
map 메서드를 통해 배열 데이터를 순회하여 표시할 수 있음.  

```jsx
import React from 'react';

import Todo from './Todo'

export const DUMMY_TODOS = [
    'Learn React',
    'Practice React',
    'Profit!'
];

export default function App() {
  return (
    <ul>
      {/*정적으로 출력*/}
      {/* {Todo(DUMMY_TODOS[0])}
      {Todo(DUMMY_TODOS[1])}
      {Todo(DUMMY_TODOS[2])} */}

      {/*동적으로 출력*/}
      {DUMMY_TODOS.map(todo=>Todo(todo))}
    </ul>
  );
}
```
```jsx
{CORE_CONCEPTS.map((conceptItem)=> <CoreConcept {...conceptItem} />)}
  {/* <CoreConcept {...CORE_CONCEPTS[0]} />
  <CoreConcept {...CORE_CONCEPTS[1]} />
  <CoreConcept {...CORE_CONCEPTS[2]} />
  <CoreConcept {...CORE_CONCEPTS[3]} /> */}
```

## 조건부 렌더링  
조건에 따라 다른 내용을 렌더링하도록 설정할 수 있음 (예: 회원/비회원 페이지)  

```jsx
let content;
if (isLoggedIn) {
  content = <AdminPanel />;
} else {
  content = <LoginForm />;
}
return (
  <div>
    {content}
  </div>
);
```

삼항 연산자로 더 간단하게  
이것은 if 문과 달리 JSX 내부에서 작동함.
```jsx
<div>
  {isLoggedIn ? (
    <AdminPanel />
  ) : (
    <LoginForm />
  )}
</div>
```

else 분기가 필요하지 않으면 더 짧은 && 연산자를 사용할 수도 있습니다.
```jsx
<div>
  {isLoggedIn && <AdminPanel />}
</div>
```

## 반복 렌더링  
for문 및 map()함수를 통해 리스트를 렌더링할 수 있음.  

아래와 같은 product 데이터를 `map()` 함수를 통해 반복 출력할 수 있음.  

```jsx
const products = [
  { title: 'Cabbage', isFruit: false, id: 1 },
  { title: 'Garlic', isFruit: false, id: 2 },
  { title: 'Apple', isFruit: true, id: 3 },
];

export default function ShoppingList() {
  const listItems = products.map(product =>
    <li
      key={product.id}
      style={{
        color: product.isFruit ? 'magenta' : 'darkgreen'
      }}
    >
      {product.title}
    </li>
  );

  return (
    <ul>{listItems}</ul>
  );
}
```

## 이벤트 추가  

컴포넌트 내부에 이벤트 핸들러 함수를 선언하여 이벤트를 추가할 수 있음.  

```jsx
function MyButton() {
  function handleClick() {
    alert('You clicked me!');
  }

  return (
    <button onClick={handleClick}>
      Click me
    </button>
  );
}
```

## 화면 업데이트  

`동적으로 변화하는 특정 정보`를 실시간으로 표시하는 방법  
우선 컴포넌트에 react에서 `useState`를 import해야 함.  
그리고 useState 변수를 선언해줌.  

```
useState로부터 현재 state (count)와 이를 업데이트할 수 있는 함수(setCount)를 얻을 수 있습니다. 이들을 어떤 이름으로도 지정할 수 있지만 [something, setSomething]으로 작성하는 것이 일반적입니다.
```
단, 여기서 setSomething은 직접 값을 변경하는게 아님.  
React에게 요청하는 원리로 작동함.  

```jsx
import { useState } from 'react';

export default function MyApp() {
  return (
    <div>
      <h1>Counters that update separately</h1>
      <MyButton />
      <MyButton />
    </div>
  );
}

function MyButton() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1);
  }

  return (
    <button onClick={handleClick}>
      Clicked {count} times
    </button>
  );
}
```

같은 컴포넌트를 여러 개 렌더링해도, 각각의 고유한 state를 갖게 됨.  
각 버튼이 `고유한` count state를 기억하고, 다른 버튼에는 `영향을 주지 않음`.  



컴포넌트를 다른 파일에 분리해서 사용할 땐, 함수를 컴포넌트에 같이 쓰지 않고 포인터로 가리키도록 함.  

```jsx
// [App.jsx]
  function clickHandler(e){
    console.log(e.target.innerText);
  }
function App() {
  return (
    <div>
      <Header />
      <main>
        <section id="examples">
          <h2>예시들</h2>
          <menu>
              <TapButton onSelect={clickHandler}>컴포넌트</TapButton>
              <TapButton onSelect={clickHandler}>JSX</TapButton>
              <TapButton onSelect={clickHandler}>Props</TapButton>
              <TapButton onSelect={clickHandler}>State</TapButton>
          </menu>
          여그는 출력부임다.
        </section>
      </main>
    </div>
  );
}
export default App;
```
```jsx
// [TapButton.jsx]
export default function TabButton({children, onSelect}) {
    return(
        <li><button onClick={onSelect}>{children}</button></li>
    );
}
```
onSelect에 clickHandler함수를 넘겨주고, TapButton.jsx에서 onSelect에 담겨있는 함수를 onClick 이벤트 핸들러로 넘겨줌  

만약 버튼 별로 다른 기능을 구현하고 싶을 때는?  
component 내에 조건문을 넣는 방법은 확장성이 떨어짐. 아주 안 좋은 방법.  

대신, 버튼을 눌렀을 때 handler 함수를 간접적으로 호출하는 함수(또는 익명함수)를 연결하는 방법을 쓸 수 있음.  
```jsx
  <TapButton onSelect={()=>{clickHandler('컴포넌트')}}>컴포넌트</TapButton>
  <TapButton onSelect={()=>{clickHandler('JSX')}}>JSX</TapButton>
  <TapButton onSelect={()=>{clickHandler('Props')}}>Props</TapButton>
  <TapButton onSelect={()=>{clickHandler('State')}}>State</TapButton>
```

## 조건에 따라 화면 업데이트  

```jsx
  {!seletedTopic && <p>탭을 선택하시오!!</p>}
          {seletedTopic && (
        <div id='tab-content'>
          <h3>{EXAMPLES[seletedTopic].title}</h3>
          <p>{EXAMPLES[seletedTopic].description}</p>
          <pre>
            <code>
              {EXAMPLES[seletedTopic].code}
            </code>
          </pre>
        </div>
        )}
```
```jsx
  {!seletedTopic ? 
  (<p>탭을 선택하시오!!</p>) : 
  (
<div id='tab-content'>
  <h3>{EXAMPLES[seletedTopic].title}</h3>
  <p>{EXAMPLES[seletedTopic].description}</p>
  <pre>
    <code>
      {EXAMPLES[seletedTopic].code}
    </code>
  </pre>
</div>
)
  }
```

## jsx에서 css 적용  
import 문으로 적용할 수 있음.  
```jsx
import "css파일경로";
```

## empty tag로 여러 html 요소를 전달  
매개변수로 html 요소를 전달할 때, 한가지 요소만 전달할 수 있음.  
만약 두 개 이상의 요소들을 전달하고 싶을 때는  
empty tag로 감싸면 한 요소로 인식되어 전달할 수 있음.  

```jsx
<Tabs buttons={
  <>
    <menu>
      {/* <TapButton children="텍스트"></TapButton> children prop에 값을 넣어줘도 됨 */}
      {/* 하지만 단순 text는 children이라는 props로 전달되도록 설정되어있기 때문에 태그 사이에 적어도 됨 */}
      <TabButton 
          isSelected={seletedTopic === 'components'}
          onClick={()=>{
            clickHandler('components')}}>컴포넌트</TabButton>
      <TabButton 
          isSelected={seletedTopic === 'jsx'}
          onClick={()=>{
            clickHandler('jsx')}}>JSX</TabButton>
      <TabButton 
          isSelected={seletedTopic === 'props'}
          onClick={()=>{
            clickHandler('props')}}>Props</TabButton>
      <TabButton 
          isSelected={seletedTopic === 'state'}
          onClick={()=>{
            clickHandler('state')}}>State</TabButton>
    </menu>
  </>
}> 
```

## styled-component  
템플릿 리터럴을 통해 스타일을 직접 적용할 수 있음. 이는 자바스크립트의 기존 문법.  

이를 styled-component 모듈을 통해 컴포넌트로 사용할 수 있음.  

styled 
```javascript
const ControlContainer = styled.div`
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  margin-bottom: 1.5rem;
  `  // Wrapper
```
이후 스타일이 된 div를 ControlContainer라는 이름의 컴포넌트로 사용할 수 있다.  

```jsx
<ControlContainer></ControlContainer>
```

또한 `&` 기호를 사용하여 스타일을 적용한 요소의 자식 요소에도 한 번에 스타일을 적용할 수 있음.  
Header 내 img 요소에도 한 번에 스타일을 적용할 수 있음.  
주의 : `&` 기호와 선택자를 같이 사용할 때, 공백을 사용하면 적용되지 않음.  
```jsx
  const StyledHeader = styled.header`
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    margin-top: 2rem;
    margin-bottom: 2rem;

    & img {
    object-fit: contain;
    margin-bottom: 2rem;
    width: 11rem;
    height: 11rem;
  }
  
    &:hover {
    background-color: #f0920e;
  }
```

## Ref  

https://ko.react.dev/reference/react/useRef  
```
useRef는 렌더링에 필요하지 않은 값을 참조할 수 있는 React Hook입니다.
```

값을 참조하여 사용할 수 있다고 보면 됨  
요소 내 속성에 직접적으로 연결할 수 있는 Hook.  
변경사항을 지정할 때 유용하다.  
입력창을 구현할 때 많이 이용함.  

아래와 같이 작성하면 잘 안됨  
매번 새로 입력할 때마다, 지정한 이름이 'unknown entity'로 초기화됨  

```jsx
import { useState } from "react";

export default function Player() {
  const [enteredPlayerName, setEnteredPlayerName] = useState("");
  const [submitted, setSutmitted] = useState(false);
  function handleChange(event){
    setSutmitted(false);
    setEnteredPlayerName(event.target.value);
  }
  function handleClick(){
    setSutmitted(true);
  }

  return (
    <section id="player">
      <h2>Welcome {submitted ? enteredPlayerName : 'unknown entity'}</h2>
      <p>
        <input type="text" onChange={handleChange} value={enteredPlayerName} />
        <button onClick={handleClick}>Set Name</button>
      </p>
    </section>
  );
}

```

Ref를 사용하면 위 문제를 해결할 수 있음  


```jsx
import { useState, useRef } from "react";

export default function Player() {
  const [enteredPlayerName, setEnteredPlayerName] = useState(null);
  const playerName = useRef();

  function handleClick(){
    setEnteredPlayerName(playerName.current.value);
  }

  return (
    <section id="player">
      <h2>Welcome {enteredPlayerName ? enteredPlayerName : "Unknown Entity"}</h2>
      <h2>Welcome {enteredPlayerName ?? "Unknown Entity"}</h2>
      <p>
        <input ref={playerName} type="text" />
        <button onClick={handleClick}>Set Name</button>
      </p>
    </section>
  );
}
```
꿀팁  
```jsx
  <h2>Welcome {enteredPlayerName ? enteredPlayerName : "Unknown Entity"}</h2>
  <h2>Welcome {enteredPlayerName ?? "Unknown Entity"}</h2>
  ??를 두개 적어서 약식표현 가능.
  참일 경우엔 자기 자신을, 거짓일 경우엔 오른쪽을 반환
```

## forwardRef  
다른 컴포넌트의 값을 참조하고 싶을 때 사용함.  

useRef를 통해 다른 컴포넌트 내 요소의 속성을 사용하려면  
그냥 매개변수로 ref를 전달하는 방법은 안 되고  
forwardRef를 써야함  

forwardRef를 사용할 땐  
컴포넌트 function을 감싸줌  
return 값으로 컴포넌트를 내보냄  
이 때 ref는 prop과는 별개의 매개변수로 전달되도록 해줘야함.  
```jsx
Component ({ label, ...props}, ref)
```

이러면 메인 컴포넌트에서 선언한 ref와 외부 컴포넌트에서의 ref가 연결됨  

아래는 다른 컴포넌트의 input 요소의 값을 가져와  
메인 컴포넌트의 객체에 저장하고 console로 출력하는 예시  

```jsx
import Input from './Input';
import { useRef } from 'react';

export const userData = {
  name: '',
  email: '',
};

export function App() {
  const nameRef = useRef();
  const emailRef = useRef();

  function handleSaveData() {
    userData.name = nameRef.current.value;
    userData.email = emailRef.current.value;

    console.log(userData);
  }

  return (
    <div id="app">
      <Input ref={nameRef} type="text" label="Your Name" />
      <Input ref={emailRef} type="email" label="Your E-Mail" />
      <p id="actions">
        <button onClick={handleSaveData}>Save Data</button>
      </p>
    </div>
  );
}

export default App;
```

```jsx
import { forwardRef } from "react";

 const Input = forwardRef(function Input ({ label, ...props}, ref) {
  return (
    <p className="control">
      <label>{label}</label>
      <input {...props} ref={ref}/>
    </p>
  );
});

export default Input;
```

## useImperativeHandle  
<h3>다른 컴포넌트의 함수를 사용할 수 있게 해주는 Hook.</h3>  

forwardRef는 다른 컴포넌트의 `값을 참조`한다면,  
useImperativeHandle은 다른 컴포넌트의 `함수를 참조`할 수 있음.  
보통 둘이 같이 사용함.  

외부에서 사용할 수 있는 이름의 함수를 `return` 하도록 함.  

useImperativeHandle를 사용하면,  
컴포넌트 내부에서 함수 내용을 수정해도,  
해당 컴포넌트를 불러오는 컴포넌트는 수정하지 않아도 됨.  
즉, 외부 컴포넌트 내의 함수를 참조할 수 있는 것.  

아래는 form의 reset 기능을 useImperativeHandle로 감싸서  
외부에서 clear 함수로 호출할 수 있도록 한 예시  

```jsx
import { useRef, useImperativeHandle, forwardRef } from "react";

const Form = forwardRef(function Form({...props}, ref) {
    const form = useRef();
    
    useImperativeHandle(ref, ()=>{
        return{
            clear(){
                form.current.reset();
            }
        }
    });

  return (
    <form ref={form}>
      <p>
        <label>이름</label>
        <input type="text" />
      </p>

      <p>
        <label>이메일</label>
        <input type="email" />
      </p>
      <p id="actions">
        <button>저장</button>
      </p>
    </form>
  );
});

export default Form;
```

```jsx
import Form from './Form';
import { useRef } from 'react';

export function App() {
  const formRef = useRef();

  function handleRestart() {
    formRef.current.clear();
  }

  return (
    <div id="app">
      <button onClick={handleRestart}>재시작</button>
      <Form ref = {formRef}/>
    </div>
  );
}

export default App;
```

## createPortal  
react-dom의 createPortal  

최종적으로 html에 컴포넌트들을 뿌려줄 때,  
위치를 컴포넌트 내에서 지정할 수 있도록 해주는 Hook.  

컴포넌트의 return값을 createPortal로 감싸주되,  
어느 부분에 출력할지를 추가적인 매개변수로 넣어줌.  

return createPortal(html 요소들, 뿌릴 위치)  

예시)  
```jsx
return createPortal(
	<p>출력할 내용</p>
	, document.getElementById('뿌릴 위치의 id'));
```

index.html의 id가 modal인 div에 뿌리는 예시)  

```jsx
...
    return createPortal(
    <dialog ref={dialog} className="result-modal" onClose={onReset}>
        {userLost && <h2> 당신은 패배자! </h2>}
        {!userLost && <h2> 점수는... {score}정도 랄까나? 쑻 </h2>}
        <p>목표 시간은 <strong>{targetTime}초 였으며, </strong></p>
        <p>당신이 멈춘 타이머에는 <strong>{formattedRemainingTime}초가 남았습니다.</strong></p>

        <form method="dialog" onSubmit={onReset}>
            <button>닫기</button>
        </form>
    </dialog>
    , document.getElementById('modal'));
```

이벤트 발생 시, aside 요소를 지정한 div에 출력되도록 구현한 예시)  

```jsx
[Toast.jsx]
export default function Toast({ message }) {
  return (
    <aside className="toast" data-testid="toast">
      <p>{message}</p>
    </aside>);
}
```
```jsx
[App.jsx]
import Toast from './Toast';
import { useState } from 'react';
import { createPortal } from 'react-dom';
function App() {
  const [toggleToast, setToggleToast] = useState(false);

  function handleEnrol() {
    setToggleToast(true);
    setTimeout(() => {
      setToggleToast(false);
    }, 3000);
  }

  return (
    <div id="app">
      {toggleToast && createPortal(<Toast message={'개쩌네'}/>, document.getElementById("app"))}
      <article>
        <h2>React Course</h2>
        <p>
          리액트를 처음부터 끝까지 깊이있게! 고향의 맛!
        </p>
        <button onClick={handleEnrol}>Enrol</button>
      </article>
    </div>
  );
}

export default App;
```

# Context API  
Redux를 사용하기도 함.  

이건 노션에 정리했음.  
https://lucky-dinghy-f67.notion.site/09-03-Context-API-fcc5d9fc647d4ad9af31da027ed9f666?pvs=4  

