## class명 지정  
React에서는 className으로 CSS 클래스를 지정합니다.  
```jsx
<img className="avatar" />
```
```css
.avatar {
  border-radius: 50%;
}
```

클릭하면 class 속성이 생기도록 하는 예시  
```jsx
import React from 'react';
import './index.css';
import { useState } from 'react';

// don't change the Component name "App"
export default function App() {
    const [isSelected, setIsSelected] = useState(false);
    return (
        <div>
            <p className={isSelected?'selected':undefined}>Style me!</p>
            <button onClick={()=>{setIsSelected(!isSelected)}}>Toggle style</button>
        </div>
    );
}
```

## forwarding props(프롭들 전달)  

아래 방식처럼 prop을 전달한다면, 새로운 prop이 생길때마다 두 파일 모두 수정해줘야 함.  
```jsx
[Section.jsx]
// 전달받은 title과 children을 사용하여 section 요소를 반환하는 컴포넌트
export default function Section({title, id, children}) {
    return (
        <section id={id}>
            <h2>{title}</h2>
            {children}
        </section>
    )
}
[Examples.jsx]
...
    return(
        <Section id='examples' title='예시들'>
          {/* id와 title prop을 Section 컴포넌트에 전달 */}
          <menu>
          {/* <TapButton children="텍스트"></TapButton> children prop에 값을 넣어줘도 됨 */}
          {/* 하지만 단순 text는 children이라는 props로 전달되도록 설정되어있기 때문에 태그 사이에 적어도 됨 */}
              <TapButton 
              isSelected={seletedTopic === 'components'}
              onSelect={()=>{clickHandler('components')}}>컴포넌트</TapButton>
              <TapButton 
              isSelected={seletedTopic === 'jsx'}
              onSelect={()=>{clickHandler('jsx')}}>JSX</TapButton>
              <TapButton 
              isSelected={seletedTopic === 'props'}
              onSelect={()=>{clickHandler('props')}}>Props</TapButton>
              <TapButton 
              isSelected={seletedTopic === 'state'}
              onSelect={()=>{clickHandler('state')}}>State</TapButton>
          </menu>
        {tabContent}
        </Section>
    );
```

이런 번거로움을 해결할 수 있는 방법이 forwarding props 임.  
전달받을 매개변수를 spread연산자를 사용해 `...변수명`로 받아서  
그대로 전달해주면 자동으로 속성이 추가됨.  
```jsx
[Section.jsx]
export default function Section({title, children, ...props}) {
    return (
        <section {...props}>
            <h2>{title}</h2>
            {children}
        </section>
    )
}
[Example.jsx]
...
  <Section id='examples' title='예시들' className='asdf' wowwow='asdasf'>
...
```
이렇게하면 어떤 속성이 들어와도 동적으로 속성이 추가된다.  


## 데이터 표시하기  
중괄호를 사용하면 코드에서 일부 변수를 삽입하여 사용자에게 표시할 수 있도록 자바스크립트로 “이스케이프 백” 할 수 있습니다.  
JSX 중괄호 안에 문자열 연결과 같이 더 복잡한 표현식을 넣을 수도 있습니다.  

```jsx
const user = {
  name: 'Hedy Lamarr',
  imageUrl: 'https://i.imgur.com/yXOvdOSs.jpg',
  imageSize: 90,
};

export default function Profile() {
  return (
    <>
      <h1>{user.name}</h1>
      <img
        className="avatar"
        src={user.imageUrl}
        alt={'Photo of ' + user.name}
        style={{
          width: user.imageSize,
          height: user.imageSize
        }}
      />
    </>
  );
}
```

## 데이터 반복 표시하기  
map 메서드를 통해 배열 데이터를 순회하여 표시할 수 있음.  

```jsx
import React from 'react';

import Todo from './Todo'

export const DUMMY_TODOS = [
    'Learn React',
    'Practice React',
    'Profit!'
];

export default function App() {
  return (
    <ul>
      {/*정적으로 출력*/}
      {/* {Todo(DUMMY_TODOS[0])}
      {Todo(DUMMY_TODOS[1])}
      {Todo(DUMMY_TODOS[2])} */}

      {/*동적으로 출력*/}
      {DUMMY_TODOS.map(todo=>Todo(todo))}
    </ul>
  );
}
```
```jsx
{CORE_CONCEPTS.map((conceptItem)=> <CoreConcept {...conceptItem} />)}
  {/* <CoreConcept {...CORE_CONCEPTS[0]} />
  <CoreConcept {...CORE_CONCEPTS[1]} />
  <CoreConcept {...CORE_CONCEPTS[2]} />
  <CoreConcept {...CORE_CONCEPTS[3]} /> */}
```

## 조건부 렌더링  
조건에 따라 다른 내용을 렌더링하도록 설정할 수 있음 (예: 회원/비회원 페이지)  

```jsx
let content;
if (isLoggedIn) {
  content = <AdminPanel />;
} else {
  content = <LoginForm />;
}
return (
  <div>
    {content}
  </div>
);
```

삼항 연산자로 더 간단하게  
이것은 if 문과 달리 JSX 내부에서 작동함.
```jsx
<div>
  {isLoggedIn ? (
    <AdminPanel />
  ) : (
    <LoginForm />
  )}
</div>
```

else 분기가 필요하지 않으면 더 짧은 && 연산자를 사용할 수도 있습니다.
```jsx
<div>
  {isLoggedIn && <AdminPanel />}
</div>
```

## 반복 렌더링  
for문 및 map()함수를 통해 리스트를 렌더링할 수 있음.  

아래와 같은 product 데이터를 `map()` 함수를 통해 반복 출력할 수 있음.  

```jsx
const products = [
  { title: 'Cabbage', isFruit: false, id: 1 },
  { title: 'Garlic', isFruit: false, id: 2 },
  { title: 'Apple', isFruit: true, id: 3 },
];

export default function ShoppingList() {
  const listItems = products.map(product =>
    <li
      key={product.id}
      style={{
        color: product.isFruit ? 'magenta' : 'darkgreen'
      }}
    >
      {product.title}
    </li>
  );

  return (
    <ul>{listItems}</ul>
  );
}
```

## 이벤트 추가  

컴포넌트 내부에 이벤트 핸들러 함수를 선언하여 이벤트를 추가할 수 있음.  

```jsx
function MyButton() {
  function handleClick() {
    alert('You clicked me!');
  }

  return (
    <button onClick={handleClick}>
      Click me
    </button>
  );
}
```

## 화면 업데이트  

`동적으로 변화하는 특정 정보`를 실시간으로 표시하는 방법  
우선 컴포넌트에 react에서 `useState`를 import해야 함.  
그리고 useState 변수를 선언해줌.  

```
useState로부터 현재 state (count)와 이를 업데이트할 수 있는 함수(setCount)를 얻을 수 있습니다. 이들을 어떤 이름으로도 지정할 수 있지만 [something, setSomething]으로 작성하는 것이 일반적입니다.
```
단, 여기서 setSomething은 직접 값을 변경하는게 아님.  
React에게 요청하는 원리로 작동함.  

```jsx
import { useState } from 'react';

export default function MyApp() {
  return (
    <div>
      <h1>Counters that update separately</h1>
      <MyButton />
      <MyButton />
    </div>
  );
}

function MyButton() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1);
  }

  return (
    <button onClick={handleClick}>
      Clicked {count} times
    </button>
  );
}
```

같은 컴포넌트를 여러 개 렌더링해도, 각각의 고유한 state를 갖게 됨.  
각 버튼이 `고유한` count state를 기억하고, 다른 버튼에는 `영향을 주지 않음`.  



컴포넌트를 다른 파일에 분리해서 사용할 땐, 함수를 컴포넌트에 같이 쓰지 않고 포인터로 가리키도록 함.  

```jsx
// [App.jsx]
  function clickHandler(e){
    console.log(e.target.innerText);
  }
function App() {
  return (
    <div>
      <Header />
      <main>
        <section id="examples">
          <h2>예시들</h2>
          <menu>
              <TapButton onSelect={clickHandler}>컴포넌트</TapButton>
              <TapButton onSelect={clickHandler}>JSX</TapButton>
              <TapButton onSelect={clickHandler}>Props</TapButton>
              <TapButton onSelect={clickHandler}>State</TapButton>
          </menu>
          여그는 출력부임다.
        </section>
      </main>
    </div>
  );
}
export default App;
```
```jsx
// [TapButton.jsx]
export default function TabButton({children, onSelect}) {
    return(
        <li><button onClick={onSelect}>{children}</button></li>
    );
}
```
onSelect에 clickHandler함수를 넘겨주고, TapButton.jsx에서 onSelect에 담겨있는 함수를 onClick 이벤트 핸들러로 넘겨줌  

만약 버튼 별로 다른 기능을 구현하고 싶을 때는?  
component 내에 조건문을 넣는 방법은 확장성이 떨어짐. 아주 안 좋은 방법.  

대신, 버튼을 눌렀을 때 handler 함수를 간접적으로 호출하는 함수(또는 익명함수)를 연결하는 방법을 쓸 수 있음.  
```jsx
  <TapButton onSelect={()=>{clickHandler('컴포넌트')}}>컴포넌트</TapButton>
  <TapButton onSelect={()=>{clickHandler('JSX')}}>JSX</TapButton>
  <TapButton onSelect={()=>{clickHandler('Props')}}>Props</TapButton>
  <TapButton onSelect={()=>{clickHandler('State')}}>State</TapButton>
```

## 조건에 따라 화면 업데이트  

```jsx
  {!seletedTopic && <p>탭을 선택하시오!!</p>}
          {seletedTopic && (
        <div id='tab-content'>
          <h3>{EXAMPLES[seletedTopic].title}</h3>
          <p>{EXAMPLES[seletedTopic].description}</p>
          <pre>
            <code>
              {EXAMPLES[seletedTopic].code}
            </code>
          </pre>
        </div>
        )}
```
```jsx
  {!seletedTopic ? 
  (<p>탭을 선택하시오!!</p>) : 
  (
<div id='tab-content'>
  <h3>{EXAMPLES[seletedTopic].title}</h3>
  <p>{EXAMPLES[seletedTopic].description}</p>
  <pre>
    <code>
      {EXAMPLES[seletedTopic].code}
    </code>
  </pre>
</div>
)
  }
```

## jsx에서 css 적용  
import 문으로 적용할 수 있음.  
```jsx
import "css파일경로";
```

## empty tag로 여러 html 요소를 전달  
매개변수로 html 요소를 전달할 때, 한가지 요소만 전달할 수 있음.  
만약 두 개 이상의 요소들을 전달하고 싶을 때는  
empty tag로 감싸면 한 요소로 인식되어 전달할 수 있음.  

```jsx
<Tabs buttons={
  <>
    <menu>
      {/* <TapButton children="텍스트"></TapButton> children prop에 값을 넣어줘도 됨 */}
      {/* 하지만 단순 text는 children이라는 props로 전달되도록 설정되어있기 때문에 태그 사이에 적어도 됨 */}
      <TabButton 
          isSelected={seletedTopic === 'components'}
          onClick={()=>{
            clickHandler('components')}}>컴포넌트</TabButton>
      <TabButton 
          isSelected={seletedTopic === 'jsx'}
          onClick={()=>{
            clickHandler('jsx')}}>JSX</TabButton>
      <TabButton 
          isSelected={seletedTopic === 'props'}
          onClick={()=>{
            clickHandler('props')}}>Props</TabButton>
      <TabButton 
          isSelected={seletedTopic === 'state'}
          onClick={()=>{
            clickHandler('state')}}>State</TabButton>
    </menu>
  </>
}> 
```

## styled-component  
템플릿 리터럴을 통해 스타일을 직접 적용할 수 있음. 이는 자바스크립트의 기존 문법.  

이를 styled-component 모듈을 통해 컴포넌트로 사용할 수 있음.  

styled 
```javascript
const ControlContainer = styled.div`
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  margin-bottom: 1.5rem;
  `  // Wrapper
```
이후 스타일이 된 div를 ControlContainer라는 이름의 컴포넌트로 사용할 수 있다.  

```jsx
<ControlContainer></ControlContainer>
```

또한 `&` 기호를 사용하여 스타일을 적용한 요소의 자식 요소에도 한 번에 스타일을 적용할 수 있음.  
Header 내 img 요소에도 한 번에 스타일을 적용할 수 있음.  
주의 : `&` 기호와 선택자를 같이 사용할 때, 공백을 사용하면 적용되지 않음.  
```jsx
  const StyledHeader = styled.header`
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    margin-top: 2rem;
    margin-bottom: 2rem;

    & img {
    object-fit: contain;
    margin-bottom: 2rem;
    width: 11rem;
    height: 11rem;
  }
  
    &:hover {
    background-color: #f0920e;
  }
```

## Ref  

https://ko.react.dev/reference/react/useRef  
```
useRef는 렌더링에 필요하지 않은 값을 참조할 수 있는 React Hook입니다.
```

값을 참조하여 사용할 수 있다고 보면 됨  
요소 내 속성에 직접적으로 연결할 수 있는 Hook.  
변경사항을 지정할 때 유용하다.  
입력창을 구현할 때 많이 이용함.  

아래와 같이 작성하면 잘 안됨  
매번 새로 입력할 때마다, 지정한 이름이 'unknown entity'로 초기화됨  

```jsx
import { useState } from "react";

export default function Player() {
  const [enteredPlayerName, setEnteredPlayerName] = useState("");
  const [submitted, setSutmitted] = useState(false);
  function handleChange(event){
    setSutmitted(false);
    setEnteredPlayerName(event.target.value);
  }
  function handleClick(){
    setSutmitted(true);
  }

  return (
    <section id="player">
      <h2>Welcome {submitted ? enteredPlayerName : 'unknown entity'}</h2>
      <p>
        <input type="text" onChange={handleChange} value={enteredPlayerName} />
        <button onClick={handleClick}>Set Name</button>
      </p>
    </section>
  );
}

```

Ref를 사용하면 위 문제를 해결할 수 있음  


```jsx
import { useState, useRef } from "react";

export default function Player() {
  const [enteredPlayerName, setEnteredPlayerName] = useState(null);
  const playerName = useRef();

  function handleClick(){
    setEnteredPlayerName(playerName.current.value);
  }

  return (
    <section id="player">
      <h2>Welcome {enteredPlayerName ? enteredPlayerName : "Unknown Entity"}</h2>
      <h2>Welcome {enteredPlayerName ?? "Unknown Entity"}</h2>
      <p>
        <input ref={playerName} type="text" />
        <button onClick={handleClick}>Set Name</button>
      </p>
    </section>
  );
}
```
꿀팁  
```jsx
  <h2>Welcome {enteredPlayerName ? enteredPlayerName : "Unknown Entity"}</h2>
  <h2>Welcome {enteredPlayerName ?? "Unknown Entity"}</h2>
  ??를 두개 적어서 약식표현 가능.
  참일 경우엔 자기 자신을, 거짓일 경우엔 오른쪽을 반환
```

## forwardRef  
다른 컴포넌트의 값을 참조하고 싶을 때 사용함.  

useRef를 통해 다른 컴포넌트 내 요소의 속성을 사용하려면  
그냥 매개변수로 ref를 전달하는 방법은 안 되고  
forwardRef를 써야함  

forwardRef를 사용할 땐  
컴포넌트 function을 감싸줌  
return 값으로 컴포넌트를 내보냄  
이 때 ref는 prop과는 별개의 매개변수로 전달되도록 해줘야함.  
```jsx
Component ({ label, ...props}, ref)
```

이러면 메인 컴포넌트에서 선언한 ref와 외부 컴포넌트에서의 ref가 연결됨  

아래는 다른 컴포넌트의 input 요소의 값을 가져와  
메인 컴포넌트의 객체에 저장하고 console로 출력하는 예시  

```jsx
import Input from './Input';
import { useRef } from 'react';

export const userData = {
  name: '',
  email: '',
};

export function App() {
  const nameRef = useRef();
  const emailRef = useRef();

  function handleSaveData() {
    userData.name = nameRef.current.value;
    userData.email = emailRef.current.value;

    console.log(userData);
  }

  return (
    <div id="app">
      <Input ref={nameRef} type="text" label="Your Name" />
      <Input ref={emailRef} type="email" label="Your E-Mail" />
      <p id="actions">
        <button onClick={handleSaveData}>Save Data</button>
      </p>
    </div>
  );
}

export default App;
```

```jsx
import { forwardRef } from "react";

 const Input = forwardRef(function Input ({ label, ...props}, ref) {
  return (
    <p className="control">
      <label>{label}</label>
      <input {...props} ref={ref}/>
    </p>
  );
});

export default Input;
```

## useImperativeHandle  
<h3>다른 컴포넌트의 함수를 사용할 수 있게 해주는 Hook.</h3>  

forwardRef는 다른 컴포넌트의 `값을 참조`한다면,  
useImperativeHandle은 다른 컴포넌트의 `함수를 참조`할 수 있음.  
보통 둘이 같이 사용함.  

외부에서 사용할 수 있는 이름의 함수를 `return` 하도록 함.  

useImperativeHandle를 사용하면,  
컴포넌트 내부에서 함수 내용을 수정해도,  
해당 컴포넌트를 불러오는 컴포넌트는 수정하지 않아도 됨.  
즉, 외부 컴포넌트 내의 함수를 참조할 수 있는 것.  

아래는 form의 reset 기능을 useImperativeHandle로 감싸서  
외부에서 clear 함수로 호출할 수 있도록 한 예시  

```jsx
import { useRef, useImperativeHandle, forwardRef } from "react";

const Form = forwardRef(function Form({...props}, ref) {
    const form = useRef();
    
    useImperativeHandle(ref, ()=>{
        return{
            clear(){
                form.current.reset();
            }
        }
    });

  return (
    <form ref={form}>
      <p>
        <label>이름</label>
        <input type="text" />
      </p>

      <p>
        <label>이메일</label>
        <input type="email" />
      </p>
      <p id="actions">
        <button>저장</button>
      </p>
    </form>
  );
});

export default Form;
```

```jsx
import Form from './Form';
import { useRef } from 'react';

export function App() {
  const formRef = useRef();

  function handleRestart() {
    formRef.current.clear();
  }

  return (
    <div id="app">
      <button onClick={handleRestart}>재시작</button>
      <Form ref = {formRef}/>
    </div>
  );
}

export default App;
```

## createPortal  
react-dom의 createPortal  

최종적으로 html에 컴포넌트들을 뿌려줄 때,  
위치를 컴포넌트 내에서 지정할 수 있도록 해주는 Hook.  

컴포넌트의 return값을 createPortal로 감싸주되,  
어느 부분에 출력할지를 추가적인 매개변수로 넣어줌.  

return createPortal(html 요소들, 뿌릴 위치)  

예시)  
```jsx
return createPortal(
	<p>출력할 내용</p>
	, document.getElementById('뿌릴 위치의 id'));
```

index.html의 id가 modal인 div에 뿌리는 예시)  

```jsx
...
    return createPortal(
    <dialog ref={dialog} className="result-modal" onClose={onReset}>
        {userLost && <h2> 당신은 패배자! </h2>}
        {!userLost && <h2> 점수는... {score}정도 랄까나? 쑻 </h2>}
        <p>목표 시간은 <strong>{targetTime}초 였으며, </strong></p>
        <p>당신이 멈춘 타이머에는 <strong>{formattedRemainingTime}초가 남았습니다.</strong></p>

        <form method="dialog" onSubmit={onReset}>
            <button>닫기</button>
        </form>
    </dialog>
    , document.getElementById('modal'));
```

이벤트 발생 시, aside 요소를 지정한 div에 출력되도록 구현한 예시)  

```jsx
[Toast.jsx]
export default function Toast({ message }) {
  return (
    <aside className="toast" data-testid="toast">
      <p>{message}</p>
    </aside>);
}
```
```jsx
[App.jsx]
import Toast from './Toast';
import { useState } from 'react';
import { createPortal } from 'react-dom';
function App() {
  const [toggleToast, setToggleToast] = useState(false);

  function handleEnrol() {
    setToggleToast(true);
    setTimeout(() => {
      setToggleToast(false);
    }, 3000);
  }

  return (
    <div id="app">
      {toggleToast && createPortal(<Toast message={'개쩌네'}/>, document.getElementById("app"))}
      <article>
        <h2>React Course</h2>
        <p>
          리액트를 처음부터 끝까지 깊이있게! 고향의 맛!
        </p>
        <button onClick={handleEnrol}>Enrol</button>
      </article>
    </div>
  );
}

export default App;
```

# Context API  
Redux를 사용하기도 함.  

이건 노션에 정리했음.  
https://lucky-dinghy-f67.notion.site/09-03-Context-API-fcc5d9fc647d4ad9af31da027ed9f666?pvs=4  


# Reducer  


# useEffect  
useImperative로 함수를 참조하여 조건에 따라 함수를 직접 실행하는 방법도 있지만  
(어떤 값이 어떤 상태인지 확인하고, 이에 따라 어떤 동작을 수행할지 직접 지정)  
useEffect를 사용하면, 지정한 값의 변경 여부를 기준으로 어떠한 동작을 수행하도록 로직을 짤 수도 있다.  

이게 React 사용법에 더 맞음. 작동을 React에게 맡기는 느낌.  
렌더링 사이클을 React에게 맡기지 않고 직접 설정하면  
요청이 많을 때 로직이 꼬일 수 있음.  

useEffect 함수는 return값이 없음.  

https://ko.react.dev/reference/react/useEffect  

useEffect는 언제 사용해야 하는가?  

useEffect는 요소들이 모두 렌더링된 다음에 실행됨.  

만약, 의존성을 설정하지 않으면 한 번 실행된 이후 다시 실행되지 않음.  
의존성?  
useEffect(변수,의존성);  

의존성으로 설정한 변수가 바뀔 때 실행됨.  
해당 변수를 조건으로 설정한다는 느낌.  
jsx코드가 렌더링 될 때, 언제나 자식 컴포넌트도 전부 렌더링 됨.  
조건이나 함수 지정할 때 이를 주의해야함.  

Before  
```jsx
import { forwardRef, useImperativeHandle, useRef } from 'react';
import { createPortal } from 'react-dom';

const Modal = forwardRef(function Modal({ children }, ref) {
  const dialog = useRef();

  useImperativeHandle(ref, () => {
    return {
      open: () => {
        dialog.current.showModal();
      },
      close: () => {
        dialog.current.close();
      },
    };
  });

  return createPortal(
    <dialog className="modal" ref={dialog}>
      {children}
    </dialog>,
    document.getElementById('modal')
  );
});

export default Modal;

```

After  
```jsx
import { useRef, useEffect } from 'react';
import { createPortal } from 'react-dom';

function Modal ({ open, children, onClose }) {
  const dialog = useRef();

  // useEffect는 아래 dialog가 렌더링된 뒤에 실행됨.
  useEffect(()=>{
    if(open){
      dialog.current.showModal();
    } else {
      dialog.current.close();
    }
},[open]);
  // 의존성을 빈 배열로 두면, 실행 이후 다시 실행할 수 없음.

  return createPortal(
    // Esc포함, 모달 닫힐 때 setModalIsOpen(false)를 실행
    <dialog className="modal" ref={dialog} onClose={onClose}>
      {children}
    </dialog>,
    document.getElementById('modal')
  );
};

export default Modal;

```

useEffect의 return 으로 클린업 함수를 지정할 수 있음.  
이 클린업 함수는 useEffect 내 함수가 실행되기 전에 수행되기 전에 수행됨.  

```jsx
  useEffect(()=>{
    console.log("타이머가 세팅되었씁니다.");
    setTimeout(()=>{
      onConfirm();
    }, 3000);
    return ()=>{
      // 클린업 함수
      clearTimeout();
    }
  },[]);
```

# useCallback  

https://ko.react.dev/reference/react/useCallback  

useEffect가 무한반복되는 경우를 해결할 수 있음.  
return값이 존재.

# 폼 관련 기능 지원 라이브러리  
React hook form  
Formik  

---  

# nodejs 백엔드 서버 설치 및 구동  
cd : -> backend 파일로 이동  
npm install body-parser  -> 해당 패키지 설치  
node app.js -> backend 서버 실행  

node.js로는 api를 아래와 같이 구현할 수 있음  

## nodejs 서버 api 구현  

```javascript
app.get('/user-places', async (req, res) => {
  const fileContent = await fs.readFile('./data/user-places.json');

  const places = JSON.parse(fileContent);

  res.status(200).json({ places });
});

app.put('/user-places', async (req, res) => {
  const places = req.body.places;

  await fs.writeFile('./data/user-places.json', JSON.stringify(places));

  res.status(200).json({ message: 'User places updated!' });
});
```

headers : 부가적인 내용  
데이터가 어떤 타입인지 알려주거나 함  
'Content-Type':'application/json'  

json 데이터를 주고받을 때 주의해야 함!!  
형식이 key:value인지 value만 넘어가는지 잘 확인해야 한다.  
key를 기준으로 데이터를 뽑아오는 메서드에  
value만 넘겨주게 되면 데이터를 가져올 수 없음.  

예를 들어  


```javascript
app.put('/user-places', async (req, res) => {
  const places = req.body.places;

  await fs.writeFile('./data/user-places.json', JSON.stringify(places));

  res.status(200).json({ message: 'User places updated!' });
});
```
```javascript
export async function updateUserPlaces(places) {
  const response = await fetch('http://localhost:3000/user-places',{
    method:'PUT',
    body:JSON.stringify(places),
    headers: {
      'Content-Type':'application/json'
    }
})};
```

updateUserPlaces가 "/user-places"에 PUT 요청을 넣어 places 값을 반환하는데  
이렇게하면 fs.writeFile할 때 places key를 기준으로 데이터를 가져와야 하지만  
places라는 Key는 없고, value만 있기 때문에 데이터를 가져오지 못함.  
따라서 아래와 같이 객체 형식으로 바꿔줘야함.  

```javascript
export async function updateUserPlaces(places) {
	...
    body:JSON.stringify({places : places}),
	...
  })};
```

근데 key값이 데이터 변수 명과 같으면 하나로 적어줘도 됨.  

```javascript
export async function updateUserPlaces(places) {
	...
    body:JSON.stringify({places}),
	...
  })};
```  

# Hook들을 따로 떼어서 보관하는 방법  
보통 hooks 폴더 내 `use...`.js 파일을 만들어 작성함  
React가 Hook임을 알 수 있도록 앞에 use를 붙이는게 컨벤션임.  

Hook들을 따로 떼어낸 함수에  
http request를 쏘는 함수를 매개변수로 넘겨주는 방식으로 구현.  
json 객체를 가져올 때, `:`로 가져온 객체 이름을 바꿀 수 있음.  
```jsx
	[App.jsx]
  const {isFetching, error, fetchedData : userPlaces } = useFetch(fetchUserPlaces);
```
```javascript
[useFetch.js]
import { useEffect, useState } from 'react';

export function useFetch(fetchFn){

    const [fetchedData, setFetchedData] = useState([]);
    const [isFetching, setIsFetching] = useState(false);
    const [error, setError] = useState();

  useEffect(() => {
    async function fetchData() {
      setIsFetching(true);
      try {
        const data = await fetchFn();
        setFetchedData(places);
      } catch (error) {
        setError({ message: error.message || 'Failed to fetch user places.' });
      }

      setIsFetching(false);
    }

    fetchData();
  }, [fetchFn]);

  return{
    isFetching,
    fetchedData,
    error
  }
}
```

이런 방식을 통해 커스텀 Hook을 만드는데 도움이 될 수 있음.  

# React Router  
경로에 따라 다른 화면(컴포넌트)를 렌더링하도록 도와주는 라이브러리.  

Router를 이용한 Single Page Application 작동 원리  
한 번의 요청으로 모든 html 파일들을 가져옴.  
이후 경로에 따라 다른 html 요소들을 렌더링해줌.  

Router 라이브러리 설치  
```
npm install react-router-dom  
```
https://reactrouter.com/en/main/start/tutorial  

아래 3단계를 걸쳐 설정함.  
1. 경로 정의  
2. 컴포넌트 연결  
3. 전환  

아래 방식은 근래 사용하는 방식이다.  
React Router 6.4 이후 방식  

```javascript
import { createBrowserRouter, RouterProvider } from 'react-router-dom';
import HomePage from './pages/Home';
import ProductsPage from './pages/Products';


// createBrowserRouter hook을 통해 http://localhost:3000/ 경로에 대한 라우트 설정을 추가.
// RouterProvider를 통해 라우터를 제공.

const router = createBrowserRouter([
  // '/' 루트 경로를 활성화.
  { path: '/', element: <HomePage />, },
  { path: '/products', element: <ProductsPage />, },
]);

function App() {
          // RouterProvider가 기본적으로 제공하는 prop인 router에 옵션값으로 변수 router를 지정.
  return <RouterProvider router={router} />;
}

export default App;
```

다음은 이전 사용 방식이다.  
Route 컴포넌트를 wrapper로 감싸서 사용했었음.  

```js
import { createBrowserRouter, RouterProvider, createRoutesFromElements, Route } from 'react-router-dom';
import HomePage from './pages/Home';
import ProductsPage from './pages/Products';

const routeDefinition = createRoutesFromElements(
	// Route 정의 컴포넌트들을 Route 컴포넌트로 감쌈.
  <Route>
    <Route path="/" element={<HomePage />} />
    <Route path="/products" element={<ProductsPage />} />
  </Route>
);

const router = createBrowserRouter(routeDefinition);

function App() {
  return <RouterProvider router={router} />;
}

export default App;

```

그러나 아직 싱글페이지라고 할 수 없음.  
현재는 링크에 따라 다른 페이지로 이동하게 됨.  
이것은 앵커 태그를 사용해서 그렇다.  

단순히 "a" 앵커 태그를 통해 이동하도록 하면 안됨.  
react-router-dom 라이브러리의 Link 태그를 사용해야 함.  

```javascript
<a href="/products"></a>
// 아래와 같이 변경
<Link to="products"></Link>
```