## class명 지정  
React에서는 className으로 CSS 클래스를 지정합니다.  
```jsx
<img className="avatar" />
```
```css
.avatar {
  border-radius: 50%;
}
```

클릭하면 class 속성이 생기도록 하는 예시  
```jsx
import React from 'react';
import './index.css';
import { useState } from 'react';

// don't change the Component name "App"
export default function App() {
    const [isSelected, setIsSelected] = useState(false);
    return (
        <div>
            <p className={isSelected?'selected':undefined}>Style me!</p>
            <button onClick={()=>{setIsSelected(!isSelected)}}>Toggle style</button>
        </div>
    );
}
```

## forwarding props(프롭들 전달)  

아래 방식처럼 prop을 전달한다면, 새로운 prop이 생길때마다 두 파일 모두 수정해줘야 함.  
```jsx
[Section.jsx]
// 전달받은 title과 children을 사용하여 section 요소를 반환하는 컴포넌트
export default function Section({title, id, children}) {
    return (
        <section id={id}>
            <h2>{title}</h2>
            {children}
        </section>
    )
}
[Examples.jsx]
...
    return(
        <Section id='examples' title='예시들'>
          {/* id와 title prop을 Section 컴포넌트에 전달 */}
          <menu>
          {/* <TapButton children="텍스트"></TapButton> children prop에 값을 넣어줘도 됨 */}
          {/* 하지만 단순 text는 children이라는 props로 전달되도록 설정되어있기 때문에 태그 사이에 적어도 됨 */}
              <TapButton 
              isSelected={seletedTopic === 'components'}
              onSelect={()=>{clickHandler('components')}}>컴포넌트</TapButton>
              <TapButton 
              isSelected={seletedTopic === 'jsx'}
              onSelect={()=>{clickHandler('jsx')}}>JSX</TapButton>
              <TapButton 
              isSelected={seletedTopic === 'props'}
              onSelect={()=>{clickHandler('props')}}>Props</TapButton>
              <TapButton 
              isSelected={seletedTopic === 'state'}
              onSelect={()=>{clickHandler('state')}}>State</TapButton>
          </menu>
        {tabContent}
        </Section>
    );
```

이런 번거로움을 해결할 수 있는 방법이 forwarding props 임.  
전달받을 매개변수를 spread연산자를 사용해 `...변수명`로 받아서  
그대로 전달해주면 자동으로 속성이 추가됨.  
```jsx
[Section.jsx]
export default function Section({title, children, ...props}) {
    return (
        <section {...props}>
            <h2>{title}</h2>
            {children}
        </section>
    )
}
[Example.jsx]
...
  <Section id='examples' title='예시들' className='asdf' wowwow='asdasf'>
...
```
이렇게하면 어떤 속성이 들어와도 동적으로 속성이 추가된다.  


## 데이터 표시하기  
중괄호를 사용하면 코드에서 일부 변수를 삽입하여 사용자에게 표시할 수 있도록 자바스크립트로 “이스케이프 백” 할 수 있습니다.  
JSX 중괄호 안에 문자열 연결과 같이 더 복잡한 표현식을 넣을 수도 있습니다.  

```jsx
const user = {
  name: 'Hedy Lamarr',
  imageUrl: 'https://i.imgur.com/yXOvdOSs.jpg',
  imageSize: 90,
};

export default function Profile() {
  return (
    <>
      <h1>{user.name}</h1>
      <img
        className="avatar"
        src={user.imageUrl}
        alt={'Photo of ' + user.name}
        style={{
          width: user.imageSize,
          height: user.imageSize
        }}
      />
    </>
  );
}
```

## 데이터 반복 표시하기  
map 메서드를 통해 배열 데이터를 순회하여 표시할 수 있음.  

```jsx
import React from 'react';

import Todo from './Todo'

export const DUMMY_TODOS = [
    'Learn React',
    'Practice React',
    'Profit!'
];

export default function App() {
  return (
    <ul>
      {/*정적으로 출력*/}
      {/* {Todo(DUMMY_TODOS[0])}
      {Todo(DUMMY_TODOS[1])}
      {Todo(DUMMY_TODOS[2])} */}

      {/*동적으로 출력*/}
      {DUMMY_TODOS.map(todo=>Todo(todo))}
    </ul>
  );
}
```
```jsx
{CORE_CONCEPTS.map((conceptItem)=> <CoreConcept {...conceptItem} />)}
  {/* <CoreConcept {...CORE_CONCEPTS[0]} />
  <CoreConcept {...CORE_CONCEPTS[1]} />
  <CoreConcept {...CORE_CONCEPTS[2]} />
  <CoreConcept {...CORE_CONCEPTS[3]} /> */}
```

## 조건부 렌더링  
조건에 따라 다른 내용을 렌더링하도록 설정할 수 있음 (예: 회원/비회원 페이지)  

```jsx
let content;
if (isLoggedIn) {
  content = <AdminPanel />;
} else {
  content = <LoginForm />;
}
return (
  <div>
    {content}
  </div>
);
```

삼항 연산자로 더 간단하게  
이것은 if 문과 달리 JSX 내부에서 작동함.
```jsx
<div>
  {isLoggedIn ? (
    <AdminPanel />
  ) : (
    <LoginForm />
  )}
</div>
```

else 분기가 필요하지 않으면 더 짧은 && 연산자를 사용할 수도 있습니다.
```jsx
<div>
  {isLoggedIn && <AdminPanel />}
</div>
```

## 반복 렌더링  
for문 및 map()함수를 통해 리스트를 렌더링할 수 있음.  

아래와 같은 product 데이터를 `map()` 함수를 통해 반복 출력할 수 있음.  

```jsx
const products = [
  { title: 'Cabbage', isFruit: false, id: 1 },
  { title: 'Garlic', isFruit: false, id: 2 },
  { title: 'Apple', isFruit: true, id: 3 },
];

export default function ShoppingList() {
  const listItems = products.map(product =>
    <li
      key={product.id}
      style={{
        color: product.isFruit ? 'magenta' : 'darkgreen'
      }}
    >
      {product.title}
    </li>
  );

  return (
    <ul>{listItems}</ul>
  );
}
```

## 이벤트 추가  

컴포넌트 내부에 이벤트 핸들러 함수를 선언하여 이벤트를 추가할 수 있음.  

```jsx
function MyButton() {
  function handleClick() {
    alert('You clicked me!');
  }

  return (
    <button onClick={handleClick}>
      Click me
    </button>
  );
}
```

## 화면 업데이트  

`동적으로 변화하는 특정 정보`를 실시간으로 표시하는 방법  
우선 컴포넌트에 react에서 `useState`를 import해야 함.  
그리고 useState 변수를 선언해줌.  

```
useState로부터 현재 state (count)와 이를 업데이트할 수 있는 함수(setCount)를 얻을 수 있습니다. 이들을 어떤 이름으로도 지정할 수 있지만 [something, setSomething]으로 작성하는 것이 일반적입니다.
```

```jsx
import { useState } from 'react';

export default function MyApp() {
  return (
    <div>
      <h1>Counters that update separately</h1>
      <MyButton />
      <MyButton />
    </div>
  );
}

function MyButton() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1);
  }

  return (
    <button onClick={handleClick}>
      Clicked {count} times
    </button>
  );
}
```

같은 컴포넌트를 여러 개 렌더링해도, 각각의 고유한 state를 갖게 됨.  
각 버튼이 `고유한` count state를 기억하고, 다른 버튼에는 `영향을 주지 않음`.  



컴포넌트를 다른 파일에 분리해서 사용할 땐, 함수를 컴포넌트에 같이 쓰지 않고 포인터로 가리키도록 함.  

```jsx
// [App.jsx]
  function clickHandler(e){
    console.log(e.target.innerText);
  }
function App() {
  return (
    <div>
      <Header />
      <main>
        <section id="examples">
          <h2>예시들</h2>
          <menu>
              <TapButton onSelect={clickHandler}>컴포넌트</TapButton>
              <TapButton onSelect={clickHandler}>JSX</TapButton>
              <TapButton onSelect={clickHandler}>Props</TapButton>
              <TapButton onSelect={clickHandler}>State</TapButton>
          </menu>
          여그는 출력부임다.
        </section>
      </main>
    </div>
  );
}
export default App;
```
```jsx
// [TapButton.jsx]
export default function TabButton({children, onSelect}) {
    return(
        <li><button onClick={onSelect}>{children}</button></li>
    );
}
```
onSelect에 clickHandler함수를 넘겨주고, TapButton.jsx에서 onSelect에 담겨있는 함수를 onClick 이벤트 핸들러로 넘겨줌  

만약 버튼 별로 다른 기능을 구현하고 싶을 때는?  
component 내에 조건문을 넣는 방법은 확장성이 떨어짐. 아주 안 좋은 방법.  

대신, 버튼을 눌렀을 때 handler 함수를 간접적으로 호출하는 함수(또는 익명함수)를 연결하는 방법을 쓸 수 있음.  
```jsx
  <TapButton onSelect={()=>{clickHandler('컴포넌트')}}>컴포넌트</TapButton>
  <TapButton onSelect={()=>{clickHandler('JSX')}}>JSX</TapButton>
  <TapButton onSelect={()=>{clickHandler('Props')}}>Props</TapButton>
  <TapButton onSelect={()=>{clickHandler('State')}}>State</TapButton>
```

## 조건에 따라 화면 업데이트  

```jsx
  {!seletedTopic && <p>탭을 선택하시오!!</p>}
          {seletedTopic && (
        <div id='tab-content'>
          <h3>{EXAMPLES[seletedTopic].title}</h3>
          <p>{EXAMPLES[seletedTopic].description}</p>
          <pre>
            <code>
              {EXAMPLES[seletedTopic].code}
            </code>
          </pre>
        </div>
        )}
```
```jsx
  {!seletedTopic ? 
  (<p>탭을 선택하시오!!</p>) : 
  (
<div id='tab-content'>
  <h3>{EXAMPLES[seletedTopic].title}</h3>
  <p>{EXAMPLES[seletedTopic].description}</p>
  <pre>
    <code>
      {EXAMPLES[seletedTopic].code}
    </code>
  </pre>
</div>
)
  }
```

## jsx에서 css 적용  
import 문으로 적용할 수 있음.  
```jsx
import "css파일경로";
```

## empty tag로 여러 html 요소를 전달  
매개변수로 html 요소를 전달할 때, 한가지 요소만 전달할 수 있음.  
만약 두 개 이상의 요소들을 전달하고 싶을 때는  
empty tag로 감싸면 한 요소로 인식되어 전달할 수 있음.  

```jsx
<Tabs buttons={
  <>
    <menu>
      {/* <TapButton children="텍스트"></TapButton> children prop에 값을 넣어줘도 됨 */}
      {/* 하지만 단순 text는 children이라는 props로 전달되도록 설정되어있기 때문에 태그 사이에 적어도 됨 */}
      <TabButton 
          isSelected={seletedTopic === 'components'}
          onClick={()=>{
            clickHandler('components')}}>컴포넌트</TabButton>
      <TabButton 
          isSelected={seletedTopic === 'jsx'}
          onClick={()=>{
            clickHandler('jsx')}}>JSX</TabButton>
      <TabButton 
          isSelected={seletedTopic === 'props'}
          onClick={()=>{
            clickHandler('props')}}>Props</TabButton>
      <TabButton 
          isSelected={seletedTopic === 'state'}
          onClick={()=>{
            clickHandler('state')}}>State</TabButton>
    </menu>
  </>
}> 
```